<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com</id>
    <title>Kimtanyo Blog</title>
    <updated>2021-07-12T17:19:58.734Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com"/>
    <link rel="self" href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/atom.xml"/>
    <subtitle>📝 『分享记录DS&amp;DE&amp;SDE的日常』</subtitle>
    <logo>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/images/avatar.png</logo>
    <icon>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/favicon.ico</icon>
    <rights>All rights reserved 2021, Kimtanyo Blog</rights>
    <entry>
        <title type="html"><![CDATA[CentOS7安装ShadowSocksR和Google BBR]]></title>
        <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/centos7-an-zhuang-shadowsocksr-he-google-bbr/</id>
        <link href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/centos7-an-zhuang-shadowsocksr-he-google-bbr/">
        </link>
        <updated>2021-07-12T17:11:10.000Z</updated>
        <summary type="html"><![CDATA[<p>去美国之前想做个国内服务器的个人VPS方便翻墙回来，记录一下关于国内服务器在没有代理情况下出现的许多connection failed的解决方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>去美国之前想做个国内服务器的个人VPS方便翻墙回来，记录一下关于国内服务器在没有代理情况下出现的许多connection failed的解决方法</p>
<!-- more -->
<h1 id="1-更新或安装wget">1. 更新或安装wget</h1>
<pre><code class="language-bash">yum -y install wget
</code></pre>
<h2 id="2-安装网卡工具">2. 安装网卡工具</h2>
<pre><code class="language-bash">yum install net-tools -y
</code></pre>
<p>然后断开服务器重连</p>
<h1 id="3-安装ssr">3. 安装SSR</h1>
<ul>
<li>国内服务器</li>
</ul>
<pre><code class="language-bash">wget https://github.com/mu228/ssr/raw/master/ssr.sh &amp;&amp; bash ssr.sh
# 如果connection failed可添加参数-N --no-check-certificate
</code></pre>
<ul>
<li>国外服务器</li>
</ul>
<pre><code class="language-bash">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh
# 或者
wget --no-check-certificate https://www.aloneray.com/wp-content/uploads/2019/01/shadowsocksR_CN.sh &amp;&amp; chmod +x shadowsocksR_CN.sh &amp;&amp; ./shadowsocksR_CN.sh
</code></pre>
<p>调出ShadowsocksR一键管理脚本页面：</p>
<pre><code class="language-bash">bash ssr.sh
</code></pre>
<h1 id="4-安装bbr国内服务器">4. 安装BBR（国内服务器）</h1>
<p>Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，从 4.9 开始，Linux 内核已经用上了该算法，因此先检查CentOS系统内核是否在4.9以上</p>
<ul>
<li>检查更新内核</li>
</ul>
<p><strong>查看当前核心</strong></p>
<pre><code class="language-bash">uname -r
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://www.vultrclub.com/wp-content/uploads/2017/01/bbr-1.jpg" alt="Vultr CentOS7安装Google BBR加速工具方法" loading="lazy"></figure>
<p>这里我们看到当前CENTOS7核心是<strong>3.10.0</strong>-514.2.2.el7.x86_64，这个核心是不可以安装BBR的。</p>
<p><strong>更新内核</strong></p>
<pre><code class="language-bash">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://www.vultrclub.com/wp-content/uploads/2017/01/bbr-2.jpg" alt="Vultr CentOS7安装Google BBR加速工具方法" loading="lazy"></figure>
<p><strong>安装最新内核</strong></p>
<pre><code class="language-bash">yum --enablerepo=elrepo-kernel install kernel-ml -y
</code></pre>
<p>BBR目前只支持4.9.0以上的内核，其他内核是不行的，需要更换内核才可以。</p>
<figure data-type="image" tabindex="3"><img src="https://www.vultrclub.com/wp-content/uploads/2017/01/bbr-3.jpg" alt="Vultr CentOS7安装Google BBR加速工具方法" loading="lazy"></figure>
<p><strong>检查内核是否更新</strong></p>
<pre><code class="language-bash">rpm -qa | grep kernel
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://www.vultrclub.com/wp-content/uploads/2017/01/bbr-4.jpg" alt="Vultr CentOS7安装Google BBR加速工具方法" loading="lazy"></figure>
<p>我们看到了有4.9.0以上版本的内核，需要启动才可以</p>
<pre><code class="language-bash">grub2-set-default 1
</code></pre>
<p><strong>重启</strong></p>
<pre><code class="language-bash">shutdown -r now
</code></pre>
<p><strong>检查内核是否生效</strong></p>
<pre><code class="language-bash">uname -r
</code></pre>
<p>当前内核是<strong>4.9.4</strong>-1.el7.elrepo.x86_64，在4.9.0以上可以继续</p>
<figure data-type="image" tabindex="5"><img src="https://www.vultrclub.com/wp-content/uploads/2017/01/bbr-5.jpg" alt="Vultr CentOS7安装Google BBR加速工具方法" loading="lazy"></figure>
<ul>
<li>安装Google BBR</li>
</ul>
<p><strong>安装BBR工具</strong></p>
<pre><code class="language-bash">echo 'net.core.default_qdisc=fq' | sudo tee -a /etc/sysctl.conf
echo 'net.ipv4.tcp_congestion_control=bbr' | sudo tee -a /etc/sysctl.conf
sysctl -p
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://www.vultrclub.com/wp-content/uploads/2017/01/bbr-6.jpg" alt="Vultr CentOS7安装Google BBR加速工具方法" loading="lazy"></figure>
<p><strong>检查BBR是否成功</strong></p>
<p>执行命令，看看是否是提示&quot;net.ipv4.tcp_available_congestion_control = bbr cubic reno&quot;</p>
<pre><code class="language-bash">sysctl net.ipv4.tcp_available_congestion_control
</code></pre>
<p>执行命令，是否提示bbr</p>
<pre><code class="language-bash">sysctl -n net.ipv4.tcp_congestion_control
</code></pre>
<p>执行命令，是否看到BBR提示</p>
<pre><code class="language-bash">lsmod | grep bbr
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://www.vultrclub.com/wp-content/uploads/2017/01/bbr-7.jpg" alt="img" loading="lazy"></figure>
<p>有提示bbr，则说明已经开启成功了</p>
<h1 id="5-安装bbr国外服务器">5. 安装BBR（国外服务器）</h1>
<p>安装BBR工具，增加可执行权限，开启BBR</p>
<pre><code class="language-bash">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh
chmod +x bbr.sh
./bbr.sh
</code></pre>
<p>判断BBR加速有没有开启成功。输入以下命令：</p>
<pre><code class="language-bash">sysctl net.ipv4.tcp_available_congestion_control
</code></pre>
<p>如果返回值为<code>net.ipv4.tcp_available_congestion_control = bbr cubic reno</code></p>
<p>后面有bbr，则说明已经开启成功了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[笔记]JavaSE 01- 预科+入门+基础篇]]></title>
        <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/bi-ji-javase-ji-chu-pian/</id>
        <link href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/bi-ji-javase-ji-chu-pian/">
        </link>
        <updated>2021-06-26T08:34:31.000Z</updated>
        <summary type="html"><![CDATA[<p>个人笔记记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>个人笔记记录</p>
<!-- more -->
<h1 id="java预科">Java预科</h1>
<h2 id="冯诺依曼体系结构">冯诺依曼体系结构</h2>
<figure data-type="image" tabindex="1"><img src="https://bkimg.cdn.bcebos.com/pic/a8773912b31bb051973f1da5367adab44aede020?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5" alt="冯诺依曼体系结构" loading="lazy"></figure>
<h2 id="基本的dos命令">基本的DOS命令</h2>
<p>打开CMD的方式</p>
<ol>
<li>
<p>开始+系统+命令提示符</p>
</li>
<li>
<p>Win键+R输入cmd打开控制台（推荐使用）</p>
</li>
<li>
<p>在任意的文件来下面，按住 shift键+鼠标右键点击，在此处打开命令行窗口</p>
</li>
<li>
<p>资源管理器的地址输入：cmd + 空格 + 绝对路径（在运行代码文件的时候有用）</p>
</li>
</ol>
<p>以管理员身份运行CMD</p>
<p>​	按Ctrl+Q进入开始菜单的搜索栏，输入cmd，点击<code>以管理员身份运行</code></p>
<p>常用的DOS命令</p>
<pre><code># 盘符切换 
D:
C:
E:

# 查看当前目录下的所有文件 (directory)
dir

# 切换目录 (change directory)
cd /d 完整路径

# 进入当前的上一级目录
cd ..

# 进入当前的下一级目录
cd 文件夹

# 清理屏幕 (clear screen)
cls

# 退出终端
exit

# 查看电脑ip配质 (ip configure)
ipconfig

#打开应用
    # 计算器 (calculator)
    calc
    # 画图工具 (Microsoft painter)
    mspaint
    # 记事本
    notepad
    
# 网络命令
    # ping命令 (测试网络是否互通，粗略判断传输质量)
    ping www.baidu.com
    # netstat命令 (查看各端口网络连接情况)
    netstat -ano
    # -a : 显示所有活动的 tcp 连接，以及计算机监听的 tcp 和 udp 端口
    # -n : 只以数字形式显示所有活动的 tcp 连接的地址和端口号
    # -o : 显示活动的 tcp 连接并包括每个连接的进程id (PID)
    # 查找使用给定端口的活动连接和PID
    netstat -aon|findstr &quot;1080&quot;
    # 显示所有正在运行的进程
    tasklist
    # 查找给定PID对应的运行中的进程
    tasklist|findstr &quot;4568&quot;
    # 终止指定的进程
    taskkill /f /im 进程名称
    taskkill /f /pid 进程PID
    # /f : 强制终止，有时会缺少权限无法强制终止，需要管理员权限运行
    
# 文件操作
	# 新建目录 (make directory) 
	md 目录名
	# 移除目录 (remove directory)
    rd 目录名
    # 新建文件
    cd&gt; 文件名
    # 删除文件
    del 文件名

</code></pre>
<p>注意DOS不区分大小写</p>
<p>注意路径分隔符是\，而参数命令的标识符是/</p>
<p>如何路径中含有空格，需要用双引号&quot;&quot;将整个路径括起来</p>
<p>在DOS中不要用ctrl+c来复制ctrl+v来粘贴，因为ctrl+c会退出当前命令，用鼠标左键框选内容后，鼠标单击右键即可复制，再用鼠标单击右键即可粘贴</p>
<h2 id="计算机语言">计算机语言</h2>
<p>第一代语言</p>
<p>机器语言</p>
<pre><code>- 基本计算方式是基于二进制的方式
- 这种代码是直接给计算机使用的，不经过任何转换
</code></pre>
<p>第二代语言</p>
<p>汇编语言</p>
<pre><code>- 解决人类无法读懂机器语言的问题
- 指令替代二进制
- 应用：机器人，病毒，逆向工程 (对目标产品进行逆向分析，得出该产品的各项设计流程和要素，从而做出相近但不完全一样的产品)
</code></pre>
<p>第三代语言</p>
<pre><code>- 摩尔定律 (集成电路上可以容纳的晶体管数目在大约每经过18个月便会增加一倍。换言之，处理器的性能每隔两年翻一倍。)
</code></pre>
<p>高级语言</p>
<p>大体上分为面向过程和面向对象的语言</p>
<p>例如C语言是典型的面向过程的语言，C++、JAVA是典型的面向对象的语言</p>
<p>发展历程：C语言 - C++ - JAVA - C# - Python, PHP, JavaScript</p>
<h1 id="java入门">Java入门</h1>
<h2 id="java三大版本与jdk-jre-jvm">Java三大版本与JDK JRE JVM</h2>
<p>JavaSE = java standard edition</p>
<p>JavaME = java micro edition</p>
<p>JavaEE = java enterprise edition</p>
<p>其中JavaME基本已经无人使用</p>
<p>JDK = Java Development Kit</p>
<p>JRE = Java Runtime Environment</p>
<p>JVM =Java Virtual Machine</p>
<p>三者是包含与被包含关系</p>
<figure data-type="image" tabindex="2"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic002.cnblogs.com%2Fimages%2F2012%2F382439%2F2012031917123015.jpg&amp;refer=http%3A%2F%2Fpic002.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1614878916&amp;t=986a1aa5114efe5cb3f77d1fc710c0e1" alt="JDK, JRE, JVM的关系" loading="lazy"></figure>
<h2 id="安装开发环境">安装开发环境</h2>
<p>在oracle官网搜索JDK8，注册账户同意协议并下载安装</p>
<p>（因为企业基本用的都是JDK8，不要下载最新的JDK13或者15）</p>
<p>注意选中取消公共JRE的安装</p>
<p>（因为JDK已经有一个专用JRE了）</p>
<p>配置环境变量：</p>
<p>​	系统变量：名称—JAVA_HOME，值—安装目录</p>
<p>​	系统变量下的Path：增加 %JAVA_HOME%\bin 和 %JAVA_HOME\jre\bin</p>
<p>测试 JDK：打开cmd输入java -version</p>
<p>另外，建议下载Notepad++作为文本编辑器</p>
<p>Notepad++默认是单实例运行的（会打开上次未关闭的所有文件），如果想更改成记事本那样的多实例需要在设置里面更改</p>
<p>此外，设置.java文件的默认打开方式为notepad++，方法：<a href="https://blog.csdn.net/haveanybody/article/details/84578995">win10设置文件默认打开方式为notepad++</a>，其中不设置兼容性也可，只要右键以管理员身份打开即可</p>
<hr>
<p>安装目录介绍：</p>
<p>​	bin文件夹（binary）：存放二进制可执行程序exe</p>
<p>​	include：存放c和c++的头文件，因为jdk是用c和c++编写的</p>
<p>​	jre：Java运行环境</p>
<p>​	lib（library）：存放Java的类库文件</p>
<p>​	src.zip：存放Java类</p>
<h2 id="helloworld">HelloWorld</h2>
<p>新建一个Code文件夹用于存放代码</p>
<p>在文件夹下新建一个Hello.txt文件后缀名改为.java</p>
<p>用notepad++打开输入以下代码：</p>
<pre><code class="language-java">public class Hello{
	public static void main(String[] args){
		System.out.print(&quot;Hello, world!&quot;);
	}
}
</code></pre>
<p>在Code文件夹下打开cmd</p>
<p>输入javac Hello.java</p>
<p>输入java Hello</p>
<p>即可运行成功</p>
<p>含义：</p>
<p>​	javac：是编译命令，将java源文件编译成同名的class字节码文件</p>
<p>​	例如：javac Hello.java将在java文件的同目录下生成Hello.class文件</p>
<p>​	java：是运行class字节码文件，由java虚拟机对字节码进行解释和运行</p>
<p>​	例如：java Hello将成功解释运行Hello.class文件，打印Hello, world!</p>
<p>注意点：</p>
<ol>
<li>注意java命令后面的文件名不用加.class后缀，已经默认是.class后缀了</li>
<li>java是大小写敏感的，所以javac和java命令内容一定要分清大小写</li>
<li>代码内容尽量使用英文，有些缺少GBK支持可能报错</li>
<li>注意类名必须和文件名一样，并且首字母大写</li>
</ol>
<h2 id="编译型和解释型">编译型和解释型</h2>
<p>计算机运行代码需要将源代码转换成机器码，也就是二进制指令，根据转换的时机不同，编程语言可分为编译型和解释型</p>
<ul>
<li>编译型：必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序，比如C语言、C++等</li>
<li>解释型：可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 Python、JavaScript、PHP、Shell、MATLAB等</li>
<li>Java和 C#是一种比较奇葩的存在，它们是半编译半解释型的语言，源代码需要先转换成一种中间文件（字节码文件），然后再将中间文件拿到虚拟机中执行</li>
</ul>
<figure data-type="image" tabindex="3"><img src="http://c.biancheng.net/uploads/allimg/191231/1-1912311J415L7.gif" alt="编译型语言和解释型语言的执行流程" loading="lazy"></figure>
<p><strong>优缺点：</strong></p>
<p>编译型：</p>
<p>​	对于编译型语言，开发完成以后需要将所有的源代码都转换成可执行程序，比如 Windows 下的<code>.exe</code>文件，可执行程序里面包含的就是机器码。只要我们拥有可执行程序，就可以随时运行，不用再重新编译了，也就是“一次编译，无限次运行”。</p>
<p>​	在运行的时候，我们只需要编译生成的可执行程序，不再需要源代码和编译器了，所以说编译型语言可以脱离开发环境运行。</p>
<p>​	编译型语言一般是不能跨平台的，也就是不能在不同的操作系统之间随意切换。</p>
<p>​	编译型语言不能跨平台表现在两个方面：</p>
<p>​		1) 可执行程序不能跨平台：因为不同操作系统对可执行文件的内部结构有着截然不同的要求（windows是.exe，linux是.elf）</p>
<p>​		2) 源代码不能跨平台：不同平台支持的函数、类型、变量等都可能不同</p>
<hr>
<p>解释型：</p>
<p>​	对于解释型语言，每次执行程序都需要一边转换一边执行，用到哪些源代码就将哪些源代码转换成机器码，用不到的不进行任何处理。每次执行程序时可能使用不同的功能，这个时候需要转换的源代码也不一样。</p>
<p>​	因为每次执行程序都需要重新转换源代码，所以解释型语言的执行效率天生就低于编译型语言，甚至存在数量级的差距。计算机的一些底层功能，或者关键算法，一般都使用 C/C++ 实现，只有在应用层面（比如网站开发、批处理、小工具等）才会使用解释型语言。</p>
<p>​	在运行解释型语言的时候，我们始终都需要源代码和解释器，所以说它无法脱离开发环境。</p>
<p>​	当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：</p>
<p>​		1) 对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是闭源的。</p>
<p>​		2) 对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是开源的。</p>
<p>​	相比于编译型语言，解释型语言几乎都能跨平台，“一次编写，到处运行”是真是存在的，而且比比皆是。解释型语言能跨平台要归功于解释器。</p>
<p>​	我们所说的跨平台，是指源代码跨平台，而不是解释器跨平台。解释器用来将源代码转换成机器码，它就是一个可执行程序，是绝对不能跨平台的。</p>
<p>​	官方需要针对不同的平台开发不同的解释器，这些解释器必须要能够遵守同样的语法，识别同样的函数，完成同样的功能，只有这样，同样的代码在不同平台的执行结果才是相同的。</p>
<p>​	你看，解释型语言之所以能够跨平台，是因为有了解释器这个中间层。在不同的平台下，解释器会将相同的源代码转换成不同的机器码，解释器帮助我们屏蔽了不同平台之间的差异。</p>
<p>Java程序运行机制</p>
<figure data-type="image" tabindex="4"><img src="http://pic.qcsdn.com/img/20190525/acf7bcd08368d6a07754d86e6e08694c.jpeg" alt="img" loading="lazy"></figure>
<p>这里的类装载器就是JVM，字节码校验器检查语法错误</p>
<h2 id="使用idea开发">使用IDEA开发</h2>
<p>IDE：集成开发环境，Integrated Development Environment，是用于提供程序开发环境的应用程序，例如eclispe、idea、visual studio</p>
<p>IDEA一般被认为是最好的Java开发工具之一，公司是JetBrains，和PyCharm同一个公司</p>
<p>百度搜索idea进入JetBrains官网，选择IntelliJ IDEA下载Ultimate版本（收费但是可以破解，参考<a href="https://shimo.im/docs/VYTcjGWCCPvXYqGy/read">三种方法</a>），不要下载community版本，因为后面的课程会用到JavaScript和SQL，而community版本虽然免费但是是没有这些功能的</p>
<p>安装时只勾选三项64-bit launcher, Add &quot;Open Folder as Project&quot;, .java，另外不要放在C盘因为会越用越大</p>
<hr>
<p>新建Project时选中Java，SDK选择安装的JDK版本（一般会自动锁定）</p>
<p>新建Hello的project</p>
<p>在项目文件夹的src子文件夹下（类文件夹）新建Java Class（.java文件）</p>
<p>输入psvm（缩写）或者main都可以自动补足为<code>public static void main(String[] args){}</code></p>
<p>输入sout可以补足为<code>System.out.println();</code></p>
<p>（println和print的唯一区别就是最后会换行，等同于print(&quot;xxx\n&quot;)，printf和C中的printf一样格式化输出）</p>
<p>与PyCharm不同，在代码行数的绿色▶按钮即可运行.java文件</p>
<p>设置优化IDEA，参考<a href="https://blog.csdn.net/zeal9s/article/details/83544074">IDEA的常见的设置和优化(功能)</a>和<a href="https://blog.csdn.net/bbj12345678/article/details/108304669">IntelliJ IDEA 性能优化</a></p>
<p>其中优化类注释和方法注释：最好参考<a href="https://www.cnblogs.com/pypua/p/11048022.html">IDEA类和方法注释模板设置（非常详细）</a>，其中Param的default value改为</p>
<pre><code>groovyScript(&quot;def result=''; def params=\&quot;${_1}\&quot;.replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) {if(i==0){result+= params[i] + ((i &lt; params.size() - 1) ? '\\n' : '')}else{result+=' * @param  ' + params[i] + ((i &lt; params.size() - 1) ? '\\n' : '')}}; return result&quot;, methodParameters()) 
</code></pre>
<p>return的值可以改成在expression处选中methodReturnType()</p>
<p>另外不建议方法注释的快捷键是Enter，最好用Tab，因为Enter会让多行注释不方便换行</p>
<h2 id="快捷键">快捷键</h2>
<ol>
<li>Ctrl + [ 和 Ctrl + ] 分别是匹配当前指针位置的上一级左大括号和右大括号，在代码特别长的时候很有用</li>
<li>CTRL + SHIFT + ENTER 在当前行任何地方可以快速在末尾生成分号，并且将代码规范化（添加空格）</li>
<li>CTRL + D 是复制当前行并粘贴到下一行（Duplicate）CTRL + Y 是删除当前行，在IDEA里面的Redo被换成了Ctrl + Shift + Z</li>
<li>ALT + ENTER 是引入(补全)局部变量，例如在<code>Math.pow(2, 3);</code>前后或者中间按下快捷键，就会变成<code>double pow = Math.pow(2, 3);</code></li>
<li>按住CTRL鼠标左键点击工具类，可以进入类的源码，点击包，可以在左侧进入包的源路径</li>
</ol>
<h1 id="java基础">Java基础</h1>
<h2 id="注释">注释</h2>
<p>新建项目流程：</p>
<ol>
<li>一般新建项目不要选择Java而是选择Empty空项目</li>
<li>而后从菜单新建module模块，选中Java和对应的SDK</li>
<li>最后从工具栏或者菜单栏打开Project Structure - Project，选择SDK和对应的Language Level（也就是8）</li>
<li>最后在module的src里面新建Java Class开始编写</li>
</ol>
<hr>
<p>要养成书写注释（Comments）的好习惯，不然不仅是别人看不懂，自己过几天也会看不懂，增加时间成本</p>
<p>单行注释（Line Comments）：//开头，快捷键Ctrl + /</p>
<p>多行注释（Block Comments）：/*开头，*/接尾，快捷键Ctrl + Shift + /</p>
<p>文档注释（JavaDoc）：/**开头再按Enter，快捷键/* + Tab（只有按照上一节<strong>使用IDEA开发</strong>设置了优化方法注释才可以）</p>
<p>注意区分注释（Comments）和注解（Annotations），注解是会被读取运行的，注释不会</p>
<h2 id="标识符和关键字">标识符和关键字</h2>
<h3 id="标识符">标识符</h3>
<h4 id="1-定义">1、定义</h4>
<p>在Java程序中，所有的由程序员自己命名的元素统称为“标识符”</p>
<h4 id="2-标识符命名规则">2、标识符命名规则</h4>
<p>标识符由数字、字母、<code>_</code>和<code>$</code>组成</p>
<p>标识符不能以数字开头</p>
<p>标识符区分大小写</p>
<p>标识符不能是关键字</p>
<p><strong>注意：</strong></p>
<p>定义类名的标识符，首字母必须大写，后面的单词首字母大写，遵循“大驼峰命名法”</p>
<p>（例如XxxXxxx）</p>
<p>定义方法标识符：首字母尽量小写，后面的单词首字母大写，遵循“小驼峰命名法”</p>
<p>（例如 xxxXxx）</p>
<p>定义变量的标识符：同小驼峰</p>
<p>定义包名：按模块分层级，使用公司的域名倒写，（例如 com.j2008.xxx）</p>
<p>定义项目名：尽量使用英文（Java项目可以使用中文，JavaWeb项目一定使用英文）</p>
<p>所有标识符尽量使用英文，不建议用拼音和中文</p>
<h3 id="关键字">关键字</h3>
<h4 id="1-定义-2">1、定义</h4>
<p>Java关键字是电脑语言里事先定义的，有特别意义的<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AF%86%E7%AC%A6/7105638">标识符</a>，有时又叫<a href="https://baike.baidu.com/item/%E4%BF%9D%E7%95%99%E5%AD%97/7674788">保留字</a>，还有特别意义的变量。Java的关键字对Java的<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067">编译器</a>有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数，一共有50个关键字（48关键字+2保留字），关键字都是小写的英文单词。</p>
<h4 id="2-java的50个关键字">2、Java的50个关键字</h4>
<figure data-type="image" tabindex="5"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/src=http___pic2.zhimg.com_v2-8408d6adff55ca7f1772f666afae9425_b.png&amp;refer=http___pic2.zhimg.jpg" alt="src=http___pic2.zhimg.com_v2-8408d6adff55ca7f1772f666afae9425_b.png&amp;refer=http___pic2.zhimg" loading="lazy"></figure>
<h2 id="数据类型">数据类型</h2>
<p><strong>强类型语言</strong>：一种强制类型定义的语言，一旦某一个变量被定义类型，如果不经过强制转换，则它永远就是该数据类型了，强类型语言包括<strong>Java</strong>、.net 、Python、C++等语言</p>
<p>例子：定义了一个整数，如果不进行强制的类型转换，则不可以将该整数转化为字符串</p>
<p><strong>弱类型语言</strong>：一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过显性强制转换。弱类型语言包括vb 、PHP、<strong>JavaScript</strong>等语言</p>
<p>例子：</p>
<pre><code class="language-vb">var A =5;
var B = &quot;5&quot;;
SumResult = A +B;
MinResult = A -B；
</code></pre>
<p>输入SumResult的答案不是10，而是55，再次是将A的类型转化为了字符串，然后进行拼接。输入MinResult的答案是0，是将B的类型转化为了数字，然后进行减法。</p>
<p>Java的数据类型分为<strong>基本类型</strong>和<strong>引用类型</strong>两大类</p>
<h4 id="基本类型"><strong>基本类型</strong></h4>
<p>（primitive type）</p>
<p><font color='red'> （笔试常考） </font></p>
<figure data-type="image" tabindex="6"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1453275%2F202004%2F1453275-20200417122916656-1751498856.png&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1614962258&amp;t=2ab9c9814ce3296aa4a198c0f1353114" alt="img" loading="lazy"></figure>
<p>补充：其中boolean类型占1位</p>
<p><mark>其中整数类型常用<strong>int</strong>（也是默认），浮点数类型常用<strong>double</strong>（也是默认）</mark></p>
<p>范围：long&gt;int&gt;short&gt;byte，double&gt;float</p>
<p><strong>注意定义long和float变量的时候，需要在赋值的数字后面分别加上L和F</strong>，也可以在赋值的数字前面分别加上(long)和(float)做强制转换但是不推荐（因为不是所有东西都可以强制转换）</p>
<p>因为赋值的数字默认是int（整数）和double（小数），而赋值的时候被赋值的变量和赋值的变量（包括数字和字符串）需要是同一数据类型，例如不能将数字赋值给String变量，而Java只会<strong>自动将范围小的数据类型转为范围大的</strong>（对于int常数来说称为**<mark>Java的常量优化机制</mark>**），反过来转换需要强制转换（因为有舍入误差）</p>
<p>如果不加L，当long变量赋值的数字在int范围内时，虽然可以将数字自动转换为long类型，再赋值给long变量；但是当数字超出int范围时，Java会认为这个数字不符合int类型，这个数字的数据类型不明确（数字本身就是一种定义，默认为int），无法进行变量定义，此时则需要在数字后面加上L，强制转换成一个long类型的数字，才能再赋值</p>
<p>如果不加F，当float变量赋值的数字是整数在int范围内时，虽然由于float取值范围大于int，可以把数字自动转换成float再赋值；但是如果float变量赋值的数字是浮点数时，浮点数默认是double类型，而float的范围又小于double，由于只会自动将范围小的数据类型转为范围大的，所以浮点数不会自动转换成float，无法与被赋值的float变量匹配，因此无法正常定义；此外，如果float变量赋值的数字是整数但是超出int范围时，同样Java会认为这个数字不符合int类型，这个数字的数据类型不明确，无法进行变量定义，此时则需要在数字后面加上F，强制转换成一个float类型的数字，才能再赋值</p>
<p>注意：Java的常量优化机制只有当等号右边仅含常量时才会生效，右边含有变量是不生效的</p>
<p>例子：</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        float a = 3.14F;
        long b = 1000000000000L;
        byte c = 10 + 30;
        System.out.println(getType(a));
        System.out.println(getType(b));
        System.out.println(getType(c));
    }
    private static String getType(Object a) {
        return a.getClass().toString();
    }
}

//以下为错误示范，这种情况下常量优化机制是不生效的
public class Demo1 {
    public static void main(String[] args) {
        int a = 10;
        byte b = a + 30;
    }
}
</code></pre>
<p>另外注意1e3和1000是不一样的，1e3 = 1.0*Math.pow(10,3)，默认是double类型，1000默认是int类型</p>
<p>char是字符，String才是字符串，char只能定义一个字（不能空可以空格）且必须单引号不能双引号，String不是关键字是一个类（可以空），且只能双引号不能单引号</p>
<p>boolean是布尔值，只能赋值true或false</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        char firstname = '陈';
        String lastname = &quot;灿东&quot;;
        boolean male = true;
        boolean female = false;
    }
}
</code></pre>
<h4 id="引用类型"><mark><strong>引用类型</strong></mark></h4>
<p>（reference type）</p>
<figure data-type="image" tabindex="7"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp1.jquerycn.cn%2F111cn%2F3%2F0%2F1474650195_6131.jpg&amp;refer=http%3A%2F%2Fp1.jquerycn.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1625134800&amp;t=f71a49e6a53b8a92cb05e63f77df4b8f" alt="img" loading="lazy"></figure>
<p>这里先知道有哪些引用类型即可，后续会慢慢讲到</p>
<h4 id="字节">字节</h4>
<p>位（bit）：是计算机内部数据儲存的最小単位，11001100是ー个8位二进制数</p>
<p>字节（byte）：是计算机中数据处理的基本单位，习惯上用大写B来表示</p>
<p>1 B（byte字节）= 8 bit（位）</p>
<p>字符：是指计算机中使用的字母、数字、字和符号</p>
<p>例子：1个byte类型数据占1 B = 8 bit，也就是1个7位二进制数字，加上一个1位表示正负号</p>
<ul>
<li>1bit表示1位</li>
<li>1Byte表示一个字节</li>
<li>1B=8b</li>
<li>1024B=1KB</li>
<li>1024KB=1M</li>
<li>1024M=1G</li>
</ul>
<p><strong>拓展：</strong></p>
<p>32位系统和64位系统的含义</p>
<p>1、32位和64位意思是处理器一次能处理的最大位数；</p>
<p>2、32位系统的最大寻址空间是2的32次方=4294967296(bit)= 4(GB)左右；</p>
<p>3、64位系统的最大寻址空间为2的64次方=4294967296(bit)的32次方，数值大于1亿GB。</p>
<p>32位系统和64位系统的区别：</p>
<p>1、CPU要求不同。CPU有32位和64位之分，32位的CPU只能安装32位系统，而64位的CPU既可以安装32位系统也可以安装64位系统。</p>
<p>2、运算速度不同。64位CPU的指令集可以运行64位数据指令，比32位CPU提高了一倍。</p>
<p>3、<strong>寻址</strong>能力不同。32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数，实际运用过程中大多数的电脑32位系统最多识别3.5GB内存，64位系统最多识别128GB内存。</p>
<p>4、软件兼容性不同。64位系统比32位系统的软件少，主要是64位系统推出的时间不长，所以64位系统的兼容性不如32位，虽然可以兼容32位软件，但是部分32位的软件在64位系统无法运行，但是目前的Win7 64位系统兼容性好了很多。</p>
<h2 id="数据类型扩展及面试题讲解">数据类型扩展及面试题讲解</h2>
<h3 id="整数拓展">整数拓展</h3>
<table>
<thead>
<tr>
<th>进制</th>
<th>二进制</th>
<th>八进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>前缀</td>
<td>0b</td>
<td>0</td>
<td>无</td>
<td>0x</td>
</tr>
</tbody>
</table>
<p>注：十六进制的数字是0<sub>9和A</sub>F</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        int a = 0b11;
        int b = 017;
        int c = 19;
        int d = 0x1F;
        System.out.println(a);// 1*2+1
        System.out.println(b);// 1*8+7
        System.out.println(c);// 1*10+9
        System.out.println(d);// 1*16+15
    }
}
</code></pre>
<h3 id="浮点数拓展">浮点数拓展</h3>
<p><mark><strong>最好完全避免使用浮点数进行比较</strong></mark></p>
<p>因为浮点数能表示的字长是有限的（有些实数是无限的）且也是离散的（不是连续取值的）</p>
<p>浮点数存在舍入误差，只是接近但不等于</p>
<p>当需要比较小数的时候，一般会使用一种数学工具类<strong>BigDecimal</strong>进行比较（以后会学到），或者允许二者存在极小误差判断<strong>Math.abs(a-b) &lt; 1E-6f</strong></p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        float a = 0.1f;
        double b = 1.0/10;
        System.out.println(a==b);// false
        System.out.println(&quot;0b&quot;+Long.toBinaryString(Double.doubleToRawLongBits(b)));
        System.out.println(&quot;0b&quot;+Long.toBinaryString(Float.floatToRawIntBits(a)));
        System.out.println(Math.abs(a-b) &lt; 1E-6f);// true
        System.out.println(&quot;====================&quot;);
        float c =232323232322323f;
        float d = c + 1;
        System.out.println(c==d);// true
        System.out.println(&quot;0b&quot;+Long.toBinaryString(Float.floatToRawIntBits(c)));
        System.out.println(&quot;0b&quot;+Long.toBinaryString(Float.floatToRawIntBits(d)));
    }
}
/*
浮点数a和b的二进制存储格式为
a：0b11111110111001100110011001100110011001100110011001100110011010
b：0b111101110011001100110011001101
十进制转二进制可能会产生无限数（即使十进制时是有限数）
因此由于4字节和8字节长度差异，a和b存在截断误差
浮点数c和d和二进制存储格式为
c：0b1010111010100110100101111111000
d：0b1010111010100110100101111111000
因为：
1 浮点数存储时,按照符号，指数，位数进行存储。
2 先将10进制数，转换成对应的二进制小数。
3 然后将小数点移至尾数第一个有效数字的右边，如果数字太大，小数点左移动得多，科学计数法指数变大，尾数变多。
4 当尾数太大，超过float或者double尾数表示范围时，将要做截断操作。
5 一个超出表示范围的大数，再加一后。此时加一很有可能被截断。
6 所有c和d没有误差
*/
</code></pre>
<p>详细的浮点数内存存储格式和过程：<a href="https://www.cnblogs.com/lingyejun/p/7451021.html">Java浮点型精度丢失问题</a></p>
<p>浮点数内存存储原理：<a href="https://blog.csdn.net/aduovip/article/details/47728921">Java 浮点数是如何存储的</a></p>
<hr>
<p><strong><mark>此外不能使用浮点数作为循环变量</mark></strong></p>
<p>例如：精度问题会导致 (float)2000000000 == 2000000050为true，所以如下的循环不会执行：</p>
<pre><code class="language-java">for (float f = (float) 2000000000; f &lt; 2000000050; f++) {
    ...
}
</code></pre>
<h3 id="二进制和十进制互相转换">二进制和十进制互相转换</h3>
<h4 id="二进制数转换成十进制数">二进制数转换成十进制数</h4>
<p>由二进制数转换成十进制数的基本做法是，把二进制数首先写成加权系数展开式，然后按十进制加法规则求和。这种做法称为&quot;<strong>按权相加</strong>&quot;法。</p>
<p>例如把二进制数 110.11 转换成十进制数。</p>
<figure data-type="image" tabindex="8"><img src="https://www.runoob.com/wp-content/uploads/2018/11/210-1.png" alt="img" loading="lazy"></figure>
<h4 id="十进制数转换为二进制数">十进制数转换为二进制数</h4>
<p>十进制数转换为二进制数时，由于整数和小数的转换方法不同，所以先将十进制数的整数部分和小数部分分别转换后，再加以合并。</p>
<ul>
<li>十进制整数转换为二进制整数</li>
</ul>
<p>十进制整数转换为二进制整数采用&quot;<strong>除2取余，逆序排列</strong>&quot;法。具体做法是：用2去除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p>
<p>例如把 (173)10 转换为二进制数。</p>
<p>解：</p>
<figure data-type="image" tabindex="9"><img src="https://www.runoob.com/wp-content/uploads/2018/11/210-2.png" alt="img" loading="lazy"></figure>
<ul>
<li>十进制小数转换为二进制小数</li>
</ul>
<p>十进制小数转换成二进制小数采用&quot;**乘2取整，顺序排列&quot;**法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。</p>
<p>然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。</p>
<p>例如把（0.8125）转换为二进制小数。</p>
<p>解：</p>
<figure data-type="image" tabindex="10"><img src="https://www.runoob.com/wp-content/uploads/2018/11/210-3.png" alt="img" loading="lazy"></figure>
<h3 id="字符拓展">字符拓展</h3>
<p>所有字符的本质还是数字</p>
<p>最早的<strong>ASCII编码</strong>的范围是<strong>0~127</strong>，只包含大小写字母、数字和一些符号</p>
<p>中文字非常多1个字节不够，至少需要2个字节，中国因此制定了GB2312编码</p>
<p>可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc_kr里，各国有各国的标准，就会不可避免的出现冲突，结果就是，在多语言混合的文本中，显示出来就会有乱码。</p>
<p>因此，Unicode应运而生。Unicode把所有的语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p><strong>Unicode</strong>标准也在不断发展，但最常用的是用<strong>2个字节</strong>表示1个字符（偏僻字符需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</p>
<p>UTF-8有个额外的好处，就是ASCII编码实际上可以被看成是UTF-8的编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20190323152444231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"></figure>
<p>ASCII、Unicode和UTF-8的关系是：Unicode是ASCII的扩展，UTF-8是Unicode的具体实现之一（unicode transformation format，还有utf-16和utf-32）</p>
<p>Unicode编码一般是2字节，表的数字范围是0 ~ 65535 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{16}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)，一般通过转义来表示U0000 ~ UFFFF (16进制)</p>
<p>Unicode编码可以用双引号&quot;&quot;也可以用单引号</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        char c1 = 'a';
        char c2 = 'A';
        System.out.println(c1);
        System.out.println((int)c1);// 强制转换数据类型为int 97
        System.out.println(c2);
        System.out.println((int)c2);// 强制转换数据类型为int 65
        char c3 = '\u0061';// 0x0061 = 97
        System.out.println(c3);
    }
}
</code></pre>
<hr>
<ul>
<li><strong>转义字符</strong></li>
</ul>
<p>首先很重要一点，转义字符是供编译器识别的。当java文件编译成.class文件后就不存在转义一说了。</p>
<p>比如，定义一个字符串String a值为双引号“。由于java的语法规定，字符串字面量是要由一对双引号括起来。如果这样定义String a = &quot; &quot; &quot;；编译器肯定识别a为空字符串，后面不成对的双引号还会报错。这时候需要一个转义字符（java选择了\）来标识中间的双引号是字符串值，而不是语法中用来包裹字符串的特殊字符。而编译后的class文件保存值“到常量池中，不存在歧义的问题（具体可以看关于class文件讲解的文章）。</p>
<p><strong>一。八进制转义序列</strong>：用于表示<strong>ascii</strong>中的字符</p>
<p>规则： \+1到3位8进制数字；范围'\000'~'\177'</p>
<p>编译器是会自动识别转义符号\后可用的数字。</p>
<p>比如:&quot;\402&quot; 超过了最大值177，编译器就会识别为改字符串为空格加上一个字符”2“，再比如”\092&quot;，9不在8进制数字中，编译器就是识别为\0和字符“92”</p>
<p><strong>二。unicode转义字符</strong>：用于表示<strong>unicode</strong>字符集中的字符</p>
<p>规则：\u + 4个十六进制数字；范围0~65535</p>
<p>必须要写全4个数字，即只能写\u0000而不能写\u0</p>
<p><strong>三。特殊字符</strong>：单引号'、双引号&quot;、反斜线\</p>
<p>java字符串定义中，双引号必须转义，即必须这样写：&quot;\&quot;&quot;；而单引号可不转义，即可以这样写&quot; ' &quot;；</p>
<p>相同的字符定义中，单引号必须转义，' \' '；双引号可不转义' &quot; '；</p>
<p>反斜线不管作为字符还是字符串的值都需转义</p>
<p><strong>四。控制字符</strong></p>
<p>\r回车</p>
<p>\n换行</p>
<p>\f走纸换页</p>
<p>\t横向挑格</p>
<p>\b退格</p>
<p>\r移动到本行开头</p>
<p>\0空字符</p>
<p>这里需要注意，unicode转义字符和其他转义类型，转义的位置不同，编译器在将程序解析成各种符号之前，先将Unicode转义字符转换成为它们所表示的字符。可以理解为==<strong>编译器先将源文件中unicode转义字符转成对应字符再解析代码意义</strong>==。也就是unicode转义字符只是字符的另一种写法，即\u0022（双引号）只改变u0022的字面含义，不改变它所代表的双引号的代码含义。</p>
<p>这就导致有些看起来语法是错的语句但实际上可以编译运行，例如</p>
<pre><code class="language-java">System.out.println(&quot;\u0022.length());
// 看起来显然缺少一个双引号，但是由于\u0022本身就是双引号，因此可以编译运行
</code></pre>
<p>反之，也会导致一些看起来没问题的语句报错，例如</p>
<pre><code class="language-java">System.out.println(&quot;\u0022&quot;);  报“未结束字符串”错误
</code></pre>
<p>unicode转义字符有点类似于SAS的宏变量，替换过程发生在编译代码之前</p>
<p><strong>拓展（以后会讲到）</strong></p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        String sa = new String(&quot;hello world&quot;);
        String sb = new String(&quot;hello world&quot;);
        System.out.println(sa==sb);// false
        String sc = &quot;hello world&quot;;
        String sd = &quot;hello world&quot;;
        System.out.println(sc==sd);// true
    }
}
</code></pre>
<p>当&quot;==&quot;比较的是基本数据类型时，比较的是数值是否一致；当比较的是引用数据类型，则比较的是对象的地址是否一致。这里new String表示根据已有的字符串original来创建String对象，会创建一个新的内存地址，不管字符串是否相同，所以二者不一致。</p>
<h3 id="布尔值拓展">布尔值拓展</h3>
<p>一般只有新手才会写if (flag == true) {}这种语句，因为它完全等价于 if (flag){}，此外注意与Python不一样，不可以写if (flag==1){}，因为在Java中boolean true和false不对应任何数值，非要对应只能自己自定义函数</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        boolean flag =true;
        if (flag == true){
            System.out.println(&quot;rookie&quot;);
        }
        if (flag){
            System.out.println(&quot;veteran&quot;);
        }
    }
}
</code></pre>
<h3 id="调试">调试</h3>
<p>在代码左侧行数右侧设置断点之后，点击Debug (Shift+F9) 按钮（小虫子图样）即可调试代码，会运行代码直到断点行，并显示参数和变量的变化过程，<strong>注意断点所在行是不会运行的</strong></p>
<h2 id="类型转换">类型转换</h2>
<p>由于Java是强类型语言，所以在进行一些运算的时候需要进行类型转换</p>
<p><strong>运算中，不同类型的数据先转化为同一类型，然后再运算</strong></p>
<figure data-type="image" tabindex="12"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F658471cd016370563925b23bcd827d69.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100&amp;refer=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1615224789&amp;t=07374b6820bf95526f795940641d824d" alt="img" loading="lazy"></figure>
<center> 从左到右依次 : 数据表示的范围从小到大 </center>
<h3 id="强制类型转换">强制类型转换</h3>
<p>强制转换的格式：<strong>（类型）变量名</strong></p>
<p>一般是<strong>从大范围到小范围</strong>进行转换（因为通常伴有截断误差）</p>
<p>例如</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        int i = 128;
        byte b = (byte)i;// 内存溢出
        // 强制转换 （类型）变量名
        System.out.println(i);// 128
        System.out.println(b);// -128
    }
}
</code></pre>
<p>其中由于byte类型的范围是-128 ~ 127，因此<strong>内存溢出</strong></p>
<p>即128 = 127 + 1 = 0111 1111（原码）+ 0b 0000 0001（原码） = 0b 0000 0001（补码） + 0b 0111 1111（补码） = 0b 1000 0000（补码）</p>
<p><mark><strong>在计算机中所有数都是以补码形式表示和储存的</strong></mark>，具体机制参考<a href="https://blog.csdn.net/zl10086111/article/details/80907428">原码、反码、补码知识详细讲解</a></p>
<ul>
<li>8位二进制数的取值范围为[1111 1111 , 0111 1111]（原码） = [1000 0000 , 0000 0000]（反码） = [-127 , 127]，其中+0原码（0000 0000）和-0原码（1000 0000）的取值不一样</li>
<li>而使用补码时，0的值唯一等于0000 0000（原码&amp;补码），原本-0的补码1 0000 0000截断后同样等于000 0000（补码），[1000 0000]（补码）则用来表示-128
<ul>
<li>-128 = (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补（1 1000 0000截断后）</li>
</ul>
</li>
<li>因此用补码表示的8位二进制数的取值范围是[1000 0000 , 0111 1111]（补码） = [-128 , 127]</li>
<li>只有补码可以带符号位一起运算</li>
<li>-128没有反码和原码表示，1000 0000（补码）计算的原码是0000 0000（原码），但其实是不对的，因为把-0和+0区分开了</li>
</ul>
<p>因此计算机将内存溢出的128认为是127+1，计算得到的补码是1000 0000（补码），即为-128</p>
<h3 id="自动类型转换">自动类型转换</h3>
<p>只能是<strong>从小范围到大范围</strong>进行转换</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        int i = 128;
        double b = i;
        System.out.println(i);// 128
        System.out.println(b);// 128
        // 精度误差
        System.out.println((int)28.7);// 28
        System.out.println((int)-45.89f);// 45
    }
}
</code></pre>
<p>注意点</p>
<ol>
<li>不能对布尔值进行转换</li>
<li>不能把对象类型转换为不相干的类型</li>
<li>在把高容量转换到低容量的时候，强制转换</li>
<li>转换的时候可能存在内存溢出，或者精度问题</li>
</ol>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        char a = 'a';
        int b = a + 1;
        System.out.println(b);// 98
        System.out.println((char)b);// b
    }
}
</code></pre>
<h3 id="溢出问题">溢出问题</h3>
<p>操作比较大的数字时，注意溢出问题</p>
<p>解决方法：定义成容量更大的数据类型，并将运算表达式中任意一处数字强制转换成该类型</p>
<pre><code class="language-java">public class Demo1 {
    public static void main(String[] args) {
        // JDK7的新特性，数字中间可以用下划线分割
        int money = 1_000_000_000;
        int years = 20;
        int total1 = money * years;// -1474836480 
        long total2 = money * years;// -1474836480 因为先运算再定义为long，运算结果已经是int上限了
        long total3 = money * (long)years;// 20000000000
        long total4 = (long)money * years;// 20000000000
        System.out.println(total1);
        System.out.println(total2);
        System.out.println(total3);
        System.out.println(total4);
    }
}
</code></pre>
<h2 id="变量-常量-作用域">变量、常量、作用域</h2>
<p>Java是强类型语言，每个变量都必须声明其类型</p>
<p>Java变量是程序中最基本的存储单元，要素包括==<strong>变量名、变量类型和作用域</strong>==</p>
<h3 id="变量">变量</h3>
<pre><code class="language-Java">type varName [=value] [{,varName=[value]}];
//数据类型 变量=值 （可以用逗号隔开来声明多个同类型变量，注意跟python的格式区别）
</code></pre>
<p>注意：</p>
<ol>
<li>每个变量都必须说明类型，可以是基本类型也可以是引用类型</li>
<li>不建议一行定义多个变量，影响程序可读性</li>
<li>可以只定义变量名和数据类型，不定义值(局部变量例外)</li>
</ol>
<h3 id="变量作用域"><mark>变量作用域</mark></h3>
<ul>
<li>类变量：独立于方法之外的变量，用 static 修饰</li>
<li>实例变量：独立于方法之外的变量，不过没有 static 修饰</li>
<li>局部变量：类的方法中的变量</li>
</ul>
<table>
<thead>
<tr>
<th>变量</th>
<th>定义位置</th>
<th>初始化值</th>
<th>生命周期</th>
<th>作用范围</th>
<th>内存位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>类变量</td>
<td>类中方法外以static关键字声明</td>
<td>有默认的初始化的值</td>
<td>第一次访问时创建,在程序结束时销毁</td>
<td>整个类中有效</td>
<td>静态存储区</td>
</tr>
<tr>
<td>实例变量</td>
<td>类中方法外</td>
<td>有默认的初始化的值</td>
<td>对象的存在而存在,随着对象的消失而消失</td>
<td>整个类中有效</td>
<td>堆内存</td>
</tr>
<tr>
<td>局部变量</td>
<td>方法内</td>
<td>不赋值不能用</td>
<td>方法的调用而存在,方法调用完毕而消失</td>
<td>所在方法有用</td>
<td>栈内存</td>
</tr>
</tbody>
</table>
<pre><code class="language-Java">public class Variable{
    // 在类中方法之外的是属性（一种特定变量）
    static int allClicks=0;     // 类变量
    String str=&quot;hello world&quot;;   // 实例变量
    
    public void method(){
        int i=0;                // 局部变量
    }
}
</code></pre>
<pre><code class="language-Java">public class Demo08 {
    // 类变量 static
    static double salary = 25_000;

    // 实例变量：从属于对象；如果不自行初始化，这类型的默认值为 整数(0) 浮点数(0.0) 字符(''=无) 布尔值(False)
    // 除了基本类型，其余默认都是null（包括String）
    String name;
    int age;

    // main方法
    public static void main(String[] args) {
        // 局部变量：必须声明和初始化值
        int i =10;
        System.out.println(i);

        // 变量类型可以是自己定义的类
        // 变量类型 变量名字 = new Demo08(); 只有变量名字可以随意命名
        Demo08 demo08 = new Demo08();
        System.out.println(demo08.age);
        System.out.println(demo08.name);
        // 类变量 static
        System.out.println(salary);   // 注意类变量不用new一个实例出来再调用
    }

    // 其他方法
    public void add(){
    //    System.out.println(i);
    //    此处报错，因为i的作用域只在定义的main方法内
    }
}

</code></pre>
<p><mark>还有一种<strong>静态代码块</strong>也可以定义变量，以后再说</mark></p>
<p>以上在面向对象中会再详细说</p>
<h3 id="常量">常量</h3>
<p>常量(constant)：初始化(initialize)后不能再改变值，是不会变动的值</p>
<p>所谓常量可以理解成一种特殊的变量，它的值被设定之后，在程序运行过程中不允许被改变</p>
<p>关键字（修饰符）：final</p>
<pre><code class="language-Java">// final 常量名 = 值;
final double PI = 3.14;
</code></pre>
<p><strong><mark>常量名一般使用全大写字符</mark></strong></p>
<pre><code class="language-Java">public class Demo09 {

    // 修饰符不存在先后顺序 static和final先后顺序无所谓（包括public和private）
    static final double PI = 3.14;

    public static void main(String[] args) {
        System.out.println(PI);
    }
}
</code></pre>
<h3 id="变量的命名规范">变量的命名规范</h3>
<ul>
<li>所有变量、方法、类名：见名知意</li>
<li>类成员变量：首字母小写和驼峰原则：monthSalary</li>
<li>局部变量：首字母小写和驼峰原则：lastName</li>
<li><strong>常量：大写字母和下划线：MAX_VALUE</strong></li>
<li><strong>类名：首字母大写和驼峰原则：GoodMan</strong></li>
<li>方法名：首字母小写和驼峰原则：runFirst()</li>
</ul>
<h2 id="基本运算符">基本运算符</h2>
<p>Java语言支持如下运算符</p>
<ul>
<li><strong>算术运算符：+，-，*，/，%，++，--</strong></li>
<li><strong>赋值运算符：=</strong></li>
<li><strong>关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=，instanceof</strong></li>
<li><strong>逻辑运算符：&amp;&amp;，||，！</strong></li>
<li>位运算符：&amp;，|，^，~，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt;（了解为主）</li>
<li>条件运算符：？：</li>
<li>扩展赋值运算符：+=，-=，*=，/=</li>
</ul>
<p>扩展：在src下新建package等同于新建子文件夹用于分类整理</p>
<figure data-type="image" tabindex="13"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210610205156100.png" alt="image-20210610205156100" loading="lazy"></figure>
<p><strong>注意：不同package中的Java文件名和类名可以重复，但不能删除第一句声明package的语句</strong></p>
<figure data-type="image" tabindex="14"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210610205438794.png" alt="image-20210610205438794" loading="lazy"></figure>
<h3 id="算术运算符">算术运算符</h3>
<pre><code class="language-Java">package operator;

public class Demo01 {
    public static void main(String[] args){
    //    二元运算符 + - * / %
        int a = 10;
        int b = 20;
        int c = 25;
        int d = 25;
        System.out.println(a+b);
        System.out.println(a-b);
        System.out.println(a*b);
        System.out.println(a/(double)b);
    }
}
/*
* 30
* -10
* 200
* 0.5
* */
// 如果直接 a/b 结果会是0 因为int运算是舍去小数部分的
</code></pre>
<pre><code class="language-Java">package operator;

public class Demo02 {
    public static void main(String[] args) {
        long a = 1231231232123123L;
        int b = 123;
        short c = 10;
        byte d = 8;

        System.out.println(a + b + c + d);  // long
        System.out.println(b + c + d);  // int
        System.out.println(c + d);  // int
        // System.out.println((String)(c + d));  // Inconvertible types; cannot cast 'int' to 'java.lang.String'
        // 算数运算中只要含任何一个long类型变量 结果就是long类型
        // 只要不含long类型 整数的算数运算结果一定是int类型 无论有没有int类型的运算变量
        float e = 0.5F;
        double f = 2.5;
        float g = 1.5F;

        System.out.println(e+f);
        System.out.println(e+g);
        // System.out.println((String)(e+g);  // Inconvertible types; cannot cast 'double' to 'java.lang.String'
        // 同理 算数运算中只要含任何一个double类型变量 结果就是double类型
        // 但是 不同的是 如果运算只含float类型变量 结果仍然为float类型
    }
}

</code></pre>
<ul>
<li>整数运算
<ul>
<li>运算中只要含任何一个long类型变量，结果就是long类型</li>
<li>只要不含long类型，运算结果一定是int类型，无论有没有int类型的运算变量</li>
</ul>
</li>
<li>浮点数运算
<ul>
<li>运算中只要含任何一个double类型变量，结果就是double类型</li>
<li>只要不含double类型，运算结果一定是float类型</li>
</ul>
</li>
<li>整数和浮点数运算之后，结果是浮点数</li>
</ul>
<h3 id="关系运算符">关系运算符</h3>
<pre><code class="language-Java">package operator;

public class Demmo03 {
    public static void main(String[] args) {
        // 关系运算符返回结果是Boolean值
        int a = 10;
        int b = 20;
        int c = 21;

        System.out.println(c%a);// %称为模运算符 是一种算术运算符
        // 注意跟数论里面一般的模运算不太一样 余数可以小于0 除数和被除数也都可以小于0

        System.out.println(a&gt;b);
        System.out.println(a&lt;b);
        System.out.println(a==b);
        System.out.println(a!=b);
    }
}
/*
* false
* true
* false
* true
* */


</code></pre>
<pre><code class="language-java">package operator;

class Bird{//父类

}
class BigBird extends Bird{//Bird的子类

}
class LittleBird extends Bird implements BirdFly{//Bird的子类加上BirdFly接口

}
interface BirdFly{

}
public class JavaKWinstanceof {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        JavaKWinstanceof myThis=new JavaKWinstanceof();
        Bird myBird=new Bird();
        BigBird myBigBird=new BigBird();
        LittleBird myLittleBird=new LittleBird();
        //打印各实例与类之间的关系
        System.out.println(myThis instanceof JavaKWinstanceof);;//打印结果：true
        System.out.println(myBird instanceof Bird);//打印结果：true
        System.out.println(myBigBird instanceof Bird);//打印结果：true     子类实例出的对象也是父类的实例
        System.out.println(myBird instanceof BigBird);//打印结果：false      父类实例出的对象不是子类的实例
        System.out.println(myLittleBird instanceof Bird);//打印结果：true  子类加上其它接口后实例出的对象也是父类的实例

    }
}

</code></pre>
<h2 id="自增自减运算符-初识math类">自增自减运算符、初识Math类</h2>
<pre><code class="language-Java">package operator;

public class Demo04 {
    public static void main(String[] args) {

    //    一元运算符  ++  --  自增  自减
        int a = 3;
        int b = a++;  // 先执行完等号右边的代码，给b赋值，再自增
        // 等价于int b = a; a = a + 1;
        System.out.println(a);
        // 等价于a = a + 1; int c = a;
        int c = ++a;  // 先自增，执行完等号右边的代码，再给b赋值

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);


    //    很多运算会使用一些工具类操作 例如数学运算会经常使用Math类
    //    幂运算  2^3 = 2**3 = 2*2*2 = 8
        double pow = Math.pow(2, 3);
        System.out.println(pow);


    }
}
/*
* 4
* 5
* 3
* 5
* 8.0
* */
</code></pre>
<h2 id="逻辑运算符-位运算符">逻辑运算符、位运算符</h2>
<p><strong>注意：</strong></p>
<ul>
<li><strong>逻辑与运算如果第一个变量是false，则结果一定是false，因此不会运行第二个变量</strong></li>
<li><strong>逻辑或运算如果第一个变量是true，则结果一定是true，因此不会运行第二个变量</strong></li>
</ul>
<p>称为<strong>短路运算</strong></p>
<pre><code class="language-java">package operator;

// 逻辑运算符
public class Demo05 {
    public static void main(String[] args) {
    //    与 (and)  或 (or)  非 (取反)
        boolean a = true;
        boolean b = false;

        System.out.println(&quot;a &amp;&amp; b : &quot; + (a &amp;&amp; b));  // 逻辑与运算：两个变量都为真结果才为true
        System.out.println(&quot;a || b : &quot; + (a || b));  // 逻辑或运算：两个变量有一个为真，则结果才会true
        System.out.println(&quot;!(a &amp;&amp; b) : &quot; + !(a &amp;&amp; b));  // 逻辑非运算：假if真，真if假

    //    短路运算
        int c = 5;
        boolean d = (c &lt; 4) &amp;&amp; (c++ &lt; 4);
        System.out.println(d);  // 与运算的第一个变量已经是false了，结果一定是false
        System.out.println(c);  // c仍然为5说明根本没执行 &amp;&amp; 后面的内容

        boolean e = (c &gt; 4) || (c++ &lt; 4);
        System.out.println(e);  // 或运算的第一个变量已经是true了，结果一定是true
        System.out.println(c);  // c仍然为5说明根本没执行 || 后面的内容
    }
}
/*
* a &amp;&amp; b : false
* a || b : true
* !(a &amp;&amp; b) : true
* false
* 5
* true
* 5
* */
</code></pre>
<p><font color='red'> （面试常考） </font></p>
<p>提问：2 * 8 = 16怎么运算最快</p>
<p>答：用2&lt;&lt;3代替2*8，因为位运算最快，效率最高</p>
<p><mark><strong>注意：以下位运算实际都是对补码做的</strong></mark>，只是除了<strong>位取反</strong>之外，其他位运算对原码和补码计算结果都一样</p>
<pre><code class="language-java">package operator;

// 位运算符：跟二进制有关
public class Demo06 {
    public static void main(String[] args) {
    //   按位与&amp;  按位或|  按位非~  按位异或^  按位取反~（连带符号位一起取反）
        /*
        * A = 0011 1100
        * B = 0000 1101
        *
        * A&amp;B = 0000 1100
        * A|B = 0011 1101
        * A^B = 0011 0001 （异或是二者不一样为1，一样为0）
        * ~B = 1111 0010 
        * */
        int A = 0b00111100;
        int B = 0b00001101;
        String str1 = Integer.toBinaryString(A &amp; B);
        String str2 = Integer.toBinaryString(A | B);
        String str3 = Integer.toBinaryString(A ^ B);
        String str4 = Integer.toBinaryString(~B);
        int i1 = Integer.parseInt(str1);
        int i2 = Integer.parseInt(str2);
        int i3 = Integer.parseInt(str3);
        // 这里因为 ~B 是负数-14，int类型占内存空间32位按补码形式存储（负数的补码前面有很多1），若按字符转为int会超出int的上限，所以直接截取后8位即可
        String r1 = String.format(&quot;%08d&quot;, i1);
        String r2 = String.format(&quot;%08d&quot;, i2);
        String r3 = String.format(&quot;%08d&quot;, i3);
        String r4 = str4.substring(str4.length()-8, str4.length());
        System.out.println(&quot;A &amp; B : &quot;+(A&amp;B)+&quot; = &quot;+r1);
        System.out.println(&quot;A | B : &quot;+(A|B)+&quot; = &quot;+r2);
        System.out.println(&quot;A ^ B : &quot;+(A^B)+&quot; = &quot;+r3);
        System.out.println(&quot;~B : &quot;+(~B)+&quot; = &quot;+r4);
        // A &amp; B : 12 = 00001100
        // A | B : 61 = 00111101
        // A ^ B : 49 = 00110001
        // ~B : -14 = 11110010


    //   提问：2 * 8 = 16怎么运算最快  答：用2&lt;&lt;3代替2*8，因为位运算最快，效率最高
    //   左移&lt;&lt;  有符号右移&gt;&gt;  无符号右移&gt;&gt;&gt;
        /*
        * 0000 0000    0
        * 0000 0001    1
        * 0000 0010    2
        * 0000 0011    3
        * 0000 0100    4
        * 0000 1000    8
        * 0001 0000    16
        * a&lt;&lt;b就是把a的二进制数字往左移动b位，等同于a * Math.pow(2,b)，右侧补000…
        * a&gt;&gt;b就是把a的二进制数字往右移动b位，等同于a / Math.pow(2,b)，右侧舍去，左侧用符号位补所有空缺的位置
        * &gt;&gt;&gt;是无符号右移  &gt;&gt;是有符号右移 没有无符号左移
        * 有符号右移&gt;&gt;就是右移之后，左边的补上符号位，正数补000…，负数补111…
        * 无符号右移&gt;&gt;&gt;就是右移之后，无论该数为正还是为负，右移之后左边都是补上000…
        * 左移&lt;&lt;不区分有符号和无符号，都是左移之后右边补上0，最左边的符号位也直接移走，所以大数字左移有可能会导致符号变化
        * a&gt;&gt;&gt;b无法写成等价的数学运算形式，但是对于a&gt;0来说，与a&gt;&gt;b是一样的
        * */

        System.out.println(&quot;java 右移&quot;);
        int a = -5;
        System.out.println(Integer.toBinaryString(a));
        System.out.println(Integer.toBinaryString(a &gt;&gt; 2)); // 有符号右移
        System.out.println(Integer.toBinaryString(a &gt;&gt;&gt; 2)); // 无符号右移

        //        java 右移
        //        11111111111111111111111111111011
        //        11111111111111111111111111111110
        //        111111111111111111111111111110      注：前边的两个0被省略了


        System.out.println(&quot;java 负数 左移&quot;);
        int b = Integer.MIN_VALUE;
        System.out.println(Integer.toBinaryString(b));
        System.out.println(Integer.toBinaryString(b &lt;&lt; 2));
        //      java 负数 左移
        //      10000000000000000000000000000000   // 前面说过，用1000……0000来表示最小值的目的是为了区分+0和-0
        //      0                                  注：不保留符号位，符号位直接移走

        System.out.println(&quot;java 正数 左移&quot;);
        int c = 5;
        System.out.println(Integer.toBinaryString(c));
        System.out.println(Integer.toBinaryString(c &lt;&lt; 2));
        //      java 正数 左移
        //      101
        //      10100

    }
}

</code></pre>
<p>手动计算位取反结果方法：</p>
<p>​	先将数字化为二进制补全应有的字节（int是32位），根据数字的原码计算补码，然后将补码各位置取反，再根据取反后的补码计算原码，将原码化作十进制即可</p>
<p>例如：上例中B=13，即0000 1101，补码等于本身，~0000 1101 =  1111 0010，1111 0010（补码）=1111 0001（反码）=1000 1110（原码）= -14，即~B = -14，计算过程实际是32位但是这楼里省略了中间的0000……和1111……结果是一样的</p>
<h2 id="三元运算符及小结">三元运算符及小结</h2>
<p>以下运算符都是用来偷懒的</p>
<h3 id="扩展赋值运算符及字符串连接符"><strong>扩展赋值运算符</strong>及<strong>字符串连接符</strong></h3>
<pre><code class="language-java">package operator;

public class Demo07 {
    public static void main(String[] args) {
        int a =10;
        int b =20;

        a+=b; // a = a+b
        System.out.println(a);
        // 30

        a-=b; // a = a-b
        System.out.println(a);
        // 10

        // 字符串连接符 + 只要两侧有一个变量是String类型，就会把另一侧的变量也自动转换为String，再进行连接
        System.out.println(a+b);
        // 30
        System.out.println(&quot;&quot;+a+b);// 这里&quot;&quot;先和a进行连接，变成&quot;10&quot;，再和20进行连接
        // 1020
        System.out.println(a+b+&quot;&quot;);// 这里a+b先进行计算，得到30，再和&quot;&quot;进行字符连接
        // 30
    }
}

</code></pre>
<h3 id="三元运算符条件运算符">三元运算符（条件运算符）</h3>
<pre><code class="language-java">package operator;

public class Demo08 {
    public static void main(String[] args) {
    //    x ? y : z
    //    如果x==true，则结果为y，否则结果为z

        int score = 80;
        String type = score &lt; 60 ? &quot;不及格&quot; : &quot;及格&quot;;
        // 等同于if语句
        System.out.println(type);
        // 及格
    }
}

</code></pre>
<h3 id="运算符优先级">运算符优先级</h3>
<p>运算符大致优先级：括号，一元运算符，一般二元运算符，三元运算符，赋值运算符与扩展赋值运算符</p>
<p>结合性：同等优先级情况下，在代码中的计算顺序（一般是从左向右计算，但有例外）</p>
<p>详细如下：（优先级2中的+和-不是算数运算符而是一元运算符，表示正负号）</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>()、[]、{}</td>
<td>从左向右</td>
</tr>
<tr>
<td>2</td>
<td>!、+、-、~、++、--</td>
<td>从右向左</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
<td>从左向右</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
<td>从左向右</td>
</tr>
<tr>
<td>5</td>
<td>«、»、&gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>7</td>
<td>==、!=</td>
<td>从左向右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>从左向右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
</tbody>
</table>
<p><strong>注意：多数运算符具有左结合性，一元运算符、三元运算符、赋值运算符具有右结合性</strong></p>
<pre><code class="language-java">package operator;

public class RightAssociation {
    public static void main(String[] args) {
        // 结合性问题
        // 三目运算	？：
        int a = 3;
        int b = 2;
        int c = 1;
        int result = a &gt; b ? a : b &gt; c ? b : c;
        //如果是左结合：
        // a &gt; b ? a : b 先计算，得到结果是a
        // a &gt; c ? b : c 后计算，得到结果是b
        // result = b = 2

        // 如果是右结合：
        // b &gt; c ? b : c 先计算，得到结果是b
        // a &gt; b ? a : b 后计算，得到结果是a
        // result = a =3

        System.out.println(&quot;result=&quot; + result);//结果是3，证明三目运算符是右结合的，即从右向左运算


        //单目运算符 ++	--	~	!	(type)	sizeof

        int single = 2;
        int re = ~ single ++;
        //左结合的话：
        // ~ single 先计算，得到结果是-3;single=2 （计算取反结果：~00…0010 -&gt; 11…1101 -&gt; 11…1100 -&gt; 10…0011 = 等于-3）
        // re = -3++后计算，得到结果是re=-3;single=3;

        //右结合的话：
        //temp=single;single=single+1;	其结果temp=2;single=3
        //re = ~ temp;~00000010（正数补码等于原码）得到11111101(补码)，11111100(反码)，10000011(原码)，即 re = -3
        System.out.println(&quot;re=&quot; + re);//re =-3
        System.out.println(&quot;single=&quot; + single);//single=-3
        
        /*
        * 计算错了
        * 以上举例不能体现单目运算符的右结合性，但是对于理解&quot;后加加&quot;赋值的过程很有帮助
        * */
    }
}

</code></pre>
<h2 id="包机制">包机制</h2>
<p>为了更好地组织类，Java提供了包机制，用于区别类名的命名空间</p>
<p>包(package)的本质就是文件夹</p>
<p>包语句的语法格式为：</p>
<pre><code class="language-java">package pkg1[.pkg2[.pkg3…]];
//  其中.是区分包的上下级路径分隔符
</code></pre>
<p><font color="red"><strong>规范：一般利用公司域名倒置座位包名</strong></font></p>
<p>例如www.baidu.com是公司域名，那包名就为com.baidu.www</p>
<p>如果无法创建多级空包，则在 project面板 &gt; show options menu齿轮 &gt; compact middle packages 取消勾选</p>
<figure data-type="image" tabindex="15"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210612000122987.png" alt="image-20210612000122987" loading="lazy"></figure>
<p>正确建立com.baidu.www的包，应该如下</p>
<figure data-type="image" tabindex="16"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210612000456738.png" alt="image-20210612000456738" loading="lazy"></figure>
<p>同理可以建立com.baidu.wenku或者com.baidu.zhidao等等其他包，等效于在baidu下面新建子包</p>
<p>然后按照规范重新格式化之前的包名如下</p>
<figure data-type="image" tabindex="17"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210612000820218.png" alt="image-20210612000820218" loading="lazy"></figure>
<p>其中的java类在idea中经过refractor，会在最上方自动补充一句<code>package com.kimtanyo.operator;</code>（但是要刷题要记得手动加）<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210612001001677.png" alt="image-20210612001001677" loading="lazy"></p>
<p>为了能够使用某一个包的成员，我们需要在Java程序中明确导入该包，使用import语句可以完成此功能</p>
<pre><code class="language-java">import package1[.package2…].(classname|*)
</code></pre>
<p>例如：</p>
<figure data-type="image" tabindex="18"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210626152256.png" alt="微信截图_20210626152256" loading="lazy"></figure>
<p>也可以导入自定义包中的java文件，但是注意导入的java文件所定义的类名不可以和当前java文件的类名重复</p>
<figure data-type="image" tabindex="19"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626152824427.png" alt="image-20210626152824427" loading="lazy"></figure>
<p>另外如果想导入某个包下所有的成员，可以使用通配符<code>*</code></p>
<figure data-type="image" tabindex="20"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626154328569.png" alt="image-20210626154328569" loading="lazy"></figure>
<p><strong>注意：如果导入的包中有类名和当前java文件类名重复，此时不会报错，但是在引用的使用会优先使用当前java文件的类</strong></p>
<p><mark><strong>课后：看阿里巴巴Java开发手册</strong></mark></p>
<h2 id="javadoc生成文档">JavaDoc生成文档</h2>
<p>JavaDoc命令是用来生成自己API文档的</p>
<p>参数信息</p>
<ul>
<li>@author 作者名</li>
<li>@version 版本号</li>
<li>@since 指明最早需要使用的jdk版本</li>
<li>@param 参数名</li>
<li>@return 返回值情况</li>
<li>@throws 异常抛出情况</li>
</ul>
<p>jdk8 API文档：<a href="https://docs.oracle.com/javase/8/docs/api/">官方地址</a>，<a href="https://www.matools.com/api/java8">中文翻译</a></p>
<h3 id="文档注释">文档注释</h3>
<p>文档注释分为类注释和方法注释，注意类注释写在类定义前面，方法注释写在方法定义前面，中间不要隔其他内容</p>
<p>快捷键是输入<code>/**</code>，然后回车，尤其是方法注释会自动补全内容</p>
<pre><code class="language-java">package com.kimtanyo.base;

/**
 * @author kimtanyo
 * @version 1.0
 * @since 1.8
 */
public class Doc {
    String name;

    /**
     *
     * @param name
     * @return
     * @throws Exception
     */

    public String test(String name)throws Exception{
        return name;
    }
}

</code></pre>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626160520494.png" alt="image-20210626160520494" style="zoom:67%;" />
<h3 id="javadoc命令行">javadoc命令行</h3>
<p>打开java文件所在文件夹</p>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626161313958.png" alt="image-20210626161313958" style="zoom: 67%;" />
<p>在文件夹导航栏输入cmd，在当前java文件的路径打开命令行，输入javadoc命令，生成指定java文件的文档，但是如果java文件中有中文，防止出现乱码，因此要用UTF-8编码且让字符集也为UTF-8</p>
<pre><code class="language-bash"># 格式：javadoc 参数 java文件名
javadoc -encoding UTF-8 -charset UTF-8 Doc.java
</code></pre>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626162213896.png" alt="image-20210626162213896"  />
<figure data-type="image" tabindex="21"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626162243547.png" alt="image-20210626162243547" loading="lazy"></figure>
<p>生成成功以后打开目录索引页index.html，会得到一个跟官方API文档极其类似的文档，打开index中的Doc类，会得到一些说明</p>
<figure data-type="image" tabindex="22"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626162414833.png" alt="image-20210626162414833" loading="lazy"></figure>
<h3 id="idea生成javadoc文档">IDEA生成JavaDoc文档</h3>
<p>打开Tools -&gt; Generate JavaDoc，选中java文件、输出路径和参数即可生成</p>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626163304748.png" alt="image-20210626163304748" style="zoom: 67%;" />
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210626163211337.png" alt="image-20210626163211337" style="zoom:67%;" />]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[笔记]Git简明教程]]></title>
        <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/bi-ji-git-jian-ming-jiao-cheng/</id>
        <link href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/bi-ji-git-jian-ming-jiao-cheng/">
        </link>
        <updated>2021-04-21T21:55:12.000Z</updated>
        <summary type="html"><![CDATA[<p>Git入门知识总结</p>
]]></summary>
        <content type="html"><![CDATA[<p>Git入门知识总结</p>
<!-- more -->
<h1 id="版本控制">版本控制</h1>
<h2 id="什么是版本控制">什么是版本控制</h2>
<p>版本控制（Reversion Control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便哈看或更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
<ul>
<li>实现跨区域多人协同开发</li>
<li>追踪和记载一个或者多个文件的历史记录</li>
<li>组织和保护你的源代码和文档</li>
<li>统计工作量</li>
<li>并行开发、提高开发效率</li>
<li>跟踪记录整个软件的开发过程</li>
<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>
</ul>
<p>简单说就是用于管理多人协同开发项目的技术。</p>
<p>没有进行版本控制的后果：</p>
<figure data-type="image" tabindex="1"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-04-20%20013235.png" alt="屏幕截图 2021-04-20 013235" loading="lazy"></figure>
<p>多人开发就必须要使用版本控制，否则代价太大</p>
<h2 id="常见的版本控制工具">常见的版本控制工具</h2>
<p>主流的版本控制器有如下这些：</p>
<ul>
<li><strong>Git</strong></li>
<li><strong>SVN</strong>（Subversion）</li>
<li>CSV（Concurrent Versions System）</li>
<li>VSS（Microsoft Visual SourceSafe）</li>
<li>Visual Studio Online</li>
</ul>
<p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、I BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是<strong>Git</strong>与<strong>SVN</strong></p>
<h2 id="版本控制分类">版本控制分类</h2>
<p>1、本地版本控制</p>
<p>记录文件每次的更新，可以对每个版本做一个快照（Snapshot），或者记录补丁文件，适合个人用，如RCS</p>
<p>简单说就是如上图那样每更新一次自己加个标识另存到本地的上一个版本旁边</p>
<figure data-type="image" tabindex="2"><img src="https://git-scm.com/book/en/v2/images/local.png" alt="" loading="lazy"></figure>
<p>2、集中版本控制</p>
<p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>
<figure data-type="image" tabindex="3"><img src="https://git-scm.com/book/en/v2/images/centralized.png" alt="" loading="lazy"></figure>
<p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p>
<p>3、分布式版本控制所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>
<p>不会因为服务器损坏或者网络问题，造成不能工作的情况。</p>
<p>但每个人都拥有全部的代码，存在一定安全隐患（删库跑路）</p>
<figure data-type="image" tabindex="4"><img src="https://git-scm.com/book/en/v2/images/distributed.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Git与SVN'最主要区别</p>
</blockquote>
<p><strong><mark>笔试常见问题</mark></strong></p>
<p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>
<p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件。</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<p>更纤细的对比见<a href="https://www.cnblogs.com/kevingrace/p/5904595.html">SVN和Git对比梳理</a></p>
<h1 id="git历史">Git历史</h1>
<p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。<br>
Linux内核开源项目有着为数众广的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991-2002年间）。到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。<br>
Linux社区中存在很多的大佬，破解研究 BitKeeper。到了2005年，开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用BitKeeper的权力。这就迫使Linux开源社区（特别是Linux的缔造者Linus Torvalds）基于使用Bitkeeper时的经验教训，开发出自己的版本系统（2周左右），也就是后来的Git。</p>
<p>Git是目前世界上最先进的分布式版本控制系统。<br>
Git是免费、开源的，最初Git是为辅助Linux内核开发的，来替代BitKeeper！</p>
<h1 id="git安装及环境配置">Git安装及环境配置</h1>
<h2 id="安装">安装</h2>
<p>打开<a href="https://git-scm.com/">Git官网</a>下载，太慢的话找阿里的镜像站或者开VPN，</p>
<figure data-type="image" tabindex="5"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-04-20%20022011.png" alt="屏幕截图 2021-04-20 022011" loading="lazy"></figure>
<p>安装完成后再开始菜单栏会有Git项，注意在任意文件夹下右键也可以直接打开Git，相当于免去切换目录的麻烦</p>
<figure data-type="image" tabindex="6"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-04-20%20022155.png" alt="屏幕截图 2021-04-20 022155" loading="lazy"></figure>
<ul>
<li>Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多</li>
<li>Git CMD：Windows风格的命令行</li>
<li>Git GUl：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</li>
</ul>
<h2 id="基本的linux命令">基本的Linux命令</h2>
<p>1）cd：改变目录。<br>
2）cd..：回退到上一个目录，直接cd进入默认目录<br>
3）pwd：显示当前所在的目录路径。<br>
4）Is（ll）：都是列出当前目录中的所有文件，只不过（两个l）列出的内容更为详细。<br>
5）touch：新建一个文件如touch index.js就会在当前目录下新建一个index.js文件。<br>
6）rm：删除一个文件，rm index.js 就会把index.js文件删除。<br>
7）mkdir：新建一个目录，就是新建一个文件夹。<br>
8）rm -r：删除一个文件夹，rm -r src删除src目录</p>
<pre><code>rm -rf / 是递归强制清除根目录下的所有文件，在Linux中切勿尝试
</code></pre>
<p>9）mv移动文件，mv index.html src，index.html是我们要移动的文件，src是目标文件夹，当然，这样写必须文件夹在同一目录下。<br>
10）reset 重新初始化终端/清屏。<br>
11）clear 清屏。<br>
12）history 查看命令历史。<br>
13）help帮助。<br>
14）exit退出。<br>
15）#表示注释</p>
<h2 id="git环境配置">Git环境配置</h2>
<p>所有的配置文件，其实都保存在本地。</p>
<p>查看配置</p>
<pre><code class="language-bash">git config -l
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210420024037349.png" alt="image-20210420024037349" loading="lazy"></figure>
<p>查看不同级别的配置文件：</p>
<pre><code class="language-bash">#查看系统配置
git config --system --list　　
#查看当前用户（global）配置
git config --global  --list
</code></pre>
<p><strong>Git相关的配置文件：</strong></p>
<p>1）Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   --system 系统级</p>
<figure data-type="image" tabindex="8"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210420024955270.png" alt="image-20210420024955270" loading="lazy"></figure>
<p>2）C:\Users\Administrator\ .gitconfig  ：只适用于当前登录用户的配置  --global 全局</p>
<figure data-type="image" tabindex="9"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210420025358343.png" alt="image-20210420025358343" loading="lazy"></figure>
<p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p>
<h2 id="设置用户名与邮箱必要">设置用户名与邮箱（必要）</h2>
<p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<pre><code class="language-bash">git config --global user.name &quot;kimtanyo&quot;  #名称
git config --global user.email &quot;chencandong0812@outlook.com&quot;   #邮箱
</code></pre>
<p>只需要做一次这个设置，如果你传递了--global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。<strong>总之--global为全局配置，不加为某个项目的特定配置。</strong></p>
<h1 id="git基本理论核心">Git基本理论（核心）</h1>
<h2 id="工作区域">工作区域</h2>
<p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/20200618233934301.png" width = "500" height = "472" alt="" align=center />
<ul>
<li>Workspace：工作区，就是你平时存放项目代码的地方</li>
<li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote Directory：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<p>我们实际操作的一般只有工作区和远程仓库，中间两个区域都在你项目初始化路径的隐藏文件夹.git下</p>
<p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/640.webp" width = "800" height = "539" alt="" align=center />
<ul>
<li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li>
<li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li>
<li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li>
<li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li>
<li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li>
<li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li>
</ul>
<h1 id="git项目搭建">Git项目搭建</h1>
<h2 id="创建工作目录与常用指令">创建工作目录与常用指令</h2>
<p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>
<p>日常使用只要记住下图6个命令：</p>
<figure data-type="image" tabindex="10"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/20210303112022859.png" alt="20210303112022859" loading="lazy"></figure>
<h2 id="本地仓库搭建">本地仓库搭建</h2>
<p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>
<p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p>
<pre><code class="language-bash"># 在当前目录新建一个Git代码库
$ git init
</code></pre>
<p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p>
<h2 id="克隆远程仓库">克隆远程仓库</h2>
<p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>
<pre><code class="language-bash"># 克隆一个项目和它的整个代码历史(版本信息)
$ git clone [url]  # https://gitee.com/kuangstudy/openclass.git
</code></pre>
<p>2、去 gitee 或者 github 上克隆一个测试</p>
<h1 id="git文件操作">Git文件操作</h1>
<h2 id="文件的四种状态">文件的四种状态</h2>
<p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code>状态变为<code>Staged</code>.</li>
<li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库（仓库）中的文件快照内容与文件夹（工作目录）中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为<code>Modified</code>. 如果使用<code>git rm</code>移出版本库, 则成为<code>Untracked</code>文件</li>
<li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存<code>staged</code>状态, 使用<code>git checkout</code>则丢弃修改过, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改 !</li>
<li><strong>Staged</strong>: 暂存状态. 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code></li>
</ul>
<h2 id="git基本命令核心">Git基本命令（核心）</h2>
<p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p>
<pre><code>#查看指定文件状态
git status [filename]

#查看所有文件状态
git status

git init                     初始化新建Git仓库
git add .                    添加所有文件到暂存区
git add [filename]           添加指定文件到暂存区
git commit -m &quot;注释内容&quot;      提交暂存区中的内容到本地仓库 -m 提交信息（git commit -message的缩写）
git diff                     查看文件修改的内容
git log                      获得历史修改记录（每次commit都会有自己的版本号和注释）
git log --pretty=oneline     使记录只显示主要的内容，一行显示
git reset --hard HEAD^       回退到上一个版本
git reflog                   获取历史版本号
git reset --hard [版本号]     回退到该版本号对应的版本
git reset --hard HEAD~100    回退到第100个版本之前
</code></pre>
<ul>
<li>
<p>git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p>
</li>
<li>
<p>git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（包括删除[前提是已经被tracked]）。add -u 不会提交新文件（untracked file）。（git add --update的缩写）</p>
</li>
<li>
<p>git add -A：以上两个功能的集合</p>
</li>
</ul>
<h2 id="忽略文件">忽略文件</h2>
<p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>
<p>在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则：</p>
<ol>
<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li>
</ol>
<pre><code>#为注释
*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!
lib.txt     #但lib.txt除外
/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp
build/       #忽略build/目录下的所有文件
doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
</code></pre>
<h3 id="详细的忽略规则">详细的忽略规则</h3>
<h4 id="gitignore-文件忽略规则">.gitignore 文件忽略规则:</h4>
<ol>
<li>开头的/如果不是标识文件夹，要表明仅忽略文件夹的话，需要在名称后面添加 /，而不是前面</li>
<li>要想忽略某文件夹，但其下部分文件不能忽略。则需要添加通配符*，然后在文件下方额外添加！开头的规则，来指出不忽略的文件或文件夹，不能直接忽略整个文件夹</li>
<li>只要写了路径，即/左右两边都有字符，那么就是指的“绝对路径”(相对仓库的，仓库.git文件夹所在目录为根目录)，但可以用*来指定层级，指定第几层子目录下的某个文件夹。</li>
<li>空格不匹配任意文件，可作为分隔符，可用反斜杠转义</li>
<li>#开头的模式标识注释，可以使用反斜杠进行转义</li>
<li>! 开头的模式标识否定，该文件将会再次被包含，<strong>如果排除了该文件的父级目录，则使用 ! 也不会再次被包含</strong>。可以使用反斜杠进行转义</li>
<li>/ 结束的模式匹配文件夹以及在该文件夹路径下的内容，也匹配子路径中的文件夹，但是不匹配该文件</li>
<li>/ 开始的模式仅匹配当前路径下的文件夹和文件，不匹配子路径中的文件夹和文件</li>
<li>**匹配多级目录，可在开始，中间，结束</li>
<li>?通用匹配单个字符</li>
<li>[]通用匹配单个字符列表</li>
<li>{}通用匹配字符串列表</li>
</ol>
<p>常用匹配示例：</p>
<ol>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">bin/: 忽略当前路径下的bin文件夹及其下内容，不忽略 bin 文件，也会忽略子路径中的bin文件夹及其下内容</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">/bin/: 仅忽略根目录下的bin文件夹及其下内容，不忽略bin文件</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">/bin: 忽略当前路径下的bin文件夹，忽略根目录下的bin文件，不忽略子路径中的bin文件夹和bin文件</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">/*.c: 忽略 cat.c，不忽略 build/cat.c</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">**/foo: 忽略/foo, a/foo, a/b/foo等，目前没看出跟foo/的区别</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">a/**/b：忽略a/b，a/x/b，a/x/y/b等</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">!/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">*.log: 忽略所有 .log 文件</span></li>
<li><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">config.php: 忽略当前路径的 config.php 文件</span></li>
</ol>
<h4 id="关于gitignore规则不生效的问题">关于.gitignore规则不生效的问题</h4>
<p>.gitignore只能忽略那些<strong>原来没有被track的文件</strong>，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。</p>
<p>解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:</p>
<pre><code class="language-bash">git rm -r --cached .
git add .
git commit -m 'update .gitignore'
</code></pre>
<h4 id="定义git全局的-gitignore-文件">定义Git全局的 .gitignore 文件</h4>
<p>除了可以在项目中定义 .gitignore 文件外，还可以设置全局的 git .gitignore 文件来管理所有Git项目的行为。这种方式在不同的项目开发者之间是不共享的，是属于项目之上Git应用级别的行为。</p>
<p>这种方式也需要创建相应的 .gitignore 文件，可以放在C:/Users/用户名/目录下。然后在使用以下命令配置Git：</p>
<pre><code class="language-bash">git config --global core.excludesfile ~/.gitignore
</code></pre>
<p><strong>自用的全局 .ignore 文件:</strong></p>
<pre><code class="language-bash">### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr
modules.xml

target/

**/.idea
**/*.iws
**/*.iml
**/*.ipr
**/modules.xml


**/mvnw
**/mvnw.cmd
**/.mvn
**/target/
**/.gitignore

### Maven ###
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
.mvn/wrapper/maven-wrapper.jar

### Java ###
# Compiled class file
*.class


</code></pre>
<h4 id="git忽略规则的优先级">Git忽略规则的优先级</h4>
<p>在 .gitingore 文件中，每一行指定一个忽略规则，Git 检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</p>
<ol>
<li>从命令行中读取可用的忽略规则</li>
<li>当前目录定义的规则</li>
<li>父级目录定义的规则，依次递推</li>
<li>$GIT_DIR/info/exclude 文件中定义的规则</li>
<li>core.excludesfile中定义的全局规则</li>
<li>Git 忽略规则匹配语法</li>
</ol>
<h1 id="配置ssh公钥和远程仓库">配置SSH公钥和远程仓库</h1>
<p>github 是有墙的，比较慢，在国内一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器</p>
<p>国内找工作可以在简历上写上自己的gitee网址，国外可以写github网址（前提是项目做的比较多，对你找工作有帮助）</p>
<p>1、设置本机绑定SSH公钥，实现免密码登录</p>
<p>查看本地C:\Users\用户名，查看是否存在<code>.ssh</code>文件夹，如果有，查看其中是否有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，如果也有，此步骤可以跳过。没有的话，创建.shh目录后，打开Git Bash，输入以下命令</p>
<pre><code># 进入 C:\Users\Administrator\.ssh 目录
# 生成公钥
ssh-keygen  -t rsa –C “youselfemail@email.com” 
# 其中-t表示指定加密算法 rsa为一种最常用的加密算法 -C表示Comment注释 后面一般接你的个人邮箱（最好跟Github邮箱保持一致，因为可能会被作为密钥的名字）
</code></pre>
<img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:80%;" />
<p>2、将公钥信息public key 添加到Github账户中</p>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/983980-20180410125740665-185456992.png" alt="img" style="zoom:80%;" />
<figure data-type="image" tabindex="11"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/983980-20180410130010050-296709590.png" alt="img" loading="lazy"></figure>
<p>3、使用码云创建一个自己的仓库！</p>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/983980-20180410130732211-279586489.png" alt="img" style="zoom: 80%;" />
<p>.gitignore一般选择Java（视你的编写语言而定），License一般选择GPL或者Apache</p>
<p>License：开源是否可以随意转载，开源但是不能商业使用，不能转载等等，加了一些使用限制，如果一个项目没有开源许可证，则等同于保留版权，也就是只能看源码，不能使用</p>
<p>4、进入创建的仓库，点击Clone or download，找到你的仓库地址：</p>
<figure data-type="image" tabindex="12"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/983980-20180410131307416-1794682687.png" alt="img" loading="lazy"></figure>
<p>然后<strong>在本地仓库路径下</strong>通过Git Bash命令</p>
<pre><code class="language-bash">git remote add origin [URL]
</code></pre>
<p>本地仓库和github仓库就连接好了</p>
<p><span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">这个操作需要对每个克隆过来的Git项目或者新建的Git项目都要做一遍</span></p>
<h1 id="idea中集成git操作">IDEA中集成Git操作</h1>
<p><strong>1、新建项目，绑定git</strong></p>
<p>有两种方式：</p>
<ul>
<li>
<p>第一种是在Git项目的目录下，也就是.git的同级路径，直接新建项目</p>
</li>
<li>
<p>第二种是将克隆或新建的项目复制到Git项目中（除了隐藏文件夹.git不能覆盖）</p>
</li>
</ul>
<p><strong>推荐第二种</strong></p>
<p>原理是.git文件夹中的config文件指明了该Git项目远程连接的仓库地址，而本机通过SSH公钥和远程仓库绑定了（SSH公钥起到了代替Github账户密码的作用），如果复制过来用别人项目的.git覆盖了你自己的.git，会导致后续Push时是对别人Git项目绑定的远程仓库进行Push，在SSH无效的情况下会需要输入别人的Github/Gitee账户密码</p>
<p>在Idea中可以看到工具栏中多了Git工具</p>
<figure data-type="image" tabindex="13"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422043720151.png" alt="image-20210422043720151" loading="lazy"></figure>
<p>在下面也可以看到多出来的Git菜单栏</p>
<figure data-type="image" tabindex="14"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422043817739.png" alt="image-20210422043817739" loading="lazy"></figure>
<p>左侧也有Commit栏，并且此时可以看到项目中各个文件/文件夹的名称颜色，<strong>红色是untracked，绿色是staged，黑色是unmodify，蓝色是modified</strong></p>
<figure data-type="image" tabindex="15"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422044023406.png" alt="image-20210422044023406" loading="lazy"></figure>
<p><strong>2、使用IDEA操作Git</strong></p>
<p>修改或新建项目中的内容，以新建new.txt、修改.gitignore为例</p>
<p>打开Commit栏，选中需要commit的内容（选中的操作已经表明了需要add哪些，因此不再需要单独的add操作）</p>
<figure data-type="image" tabindex="16"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422044515020.png" alt="image-20210422044515020" loading="lazy"></figure>
<p>在commit设置里取消这两项，否则在commit大型项目时会影响速度</p>
<figure data-type="image" tabindex="17"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422044552518.png" alt="image-20210422044552518" loading="lazy"></figure>
<p>然后点击commit按钮即可</p>
<p>PS：如果习惯传统方式的，也可以在控制台输入<code>git add .</code>和<code>git commit -m &quot;注释&quot;</code>进行操作</p>
<figure data-type="image" tabindex="18"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422044806611.png" alt="image-20210422044806611" loading="lazy"></figure>
<p>最后进行Push操作导入到Github的远程仓库中</p>
<pre><code class="language-bash"># 将本地指定分支 推送到 远程指定分支上（注意：pull的冒号是远程在前本地在后，push相反）
git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
# 将本地当前分支 推送到 远程指定分支上
git push &lt;远程仓库名&gt; &lt;远程分支名&gt;
# 将本地当前分支 推送到 与本地当前分支同名的远程分支上
git push &lt;远程仓库名&gt;
# 这里origin指的是远程主机仓库，不代表分支，master指的是本地master分支
git push origin &lt;远程分支名&gt;
git push origin master
</code></pre>
<p><strong>在克隆远程项目的时候，本地分支会自动与远程分支建立追踪关系，可以使用默认的origin来替代远程仓库名</strong></p>
<p><strong>在自己初始化并远程连接了远程仓库和本地仓库时，也指明了origin所指的远程仓库，因此可以用默认的origin来代替远程仓库名</strong>，例如：</p>
<pre><code class="language-bash">git remote add origin [url]
</code></pre>
<p>参考：<a href="http://blog.chinaunix.net/uid-31087949-id-5816994.html">git操作之pull拉取远程指定分支以及push推送到远程指定分支</a></p>
<p><em>注意：Github对于国内进行push操作会限制速度，非常慢，所以一般需要开shadowsocks走代理，但是使用Git工具时并不会默认走SS的代理</em></p>
<figure data-type="image" tabindex="19"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422042248736.png" alt="image-20210422042248736" loading="lazy"></figure>
<p>因此在开启SS时需要手动配置git的代理，在Git Bash中输入以下命令：</p>
<pre><code class="language-bash">git config --global http.proxy http://127.0.0.1:1080
git config --global https.proxy https://127.0.0.1:1080
#取消代理
# git config --global --unset http.proxy
# git config --global --unset https.proxy
</code></pre>
<p>正常使用 git push 即可</p>
<figure data-type="image" tabindex="20"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422042314431.png" alt="image-20210422042314431" loading="lazy"></figure>
<p>检查Github上的仓库可发现已成功Push</p>
<figure data-type="image" tabindex="21"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422045315403.png" alt="image-20210422045315403" loading="lazy"></figure>
<p><strong>以上均为单人开发的操作</strong></p>
<h1 id="git分支">Git分支</h1>
<figure data-type="image" tabindex="22"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/640" alt="图片" loading="lazy"></figure>
<p>分支在GIT中相对较难，目的是为了多人协作开发，可以同时工作，然后合并代码，这需要在仓库中设置开发者权限给用户（仅限私有仓库）</p>
<p>从master主分支上新建分支，相当于此时此刻给master做了一个快照，切换到新分支在上面开发，往后commit都是对新分支进行操作，不会影响master，只有当你认为代码已经足够稳定了，可以合并到master或者和他人的开发分支合并，才需要merge到master或其他分支，</p>
<p><strong>注意：merge操作本质是push级别的，不需要额外再push</strong>，push非主分支代码的时候需要指明分支名称</p>
<pre><code class="language-bash"># 将本地指定分支 推送到 远程指定分支上（注意：pull的冒号是远程在前本地在后，push相反）
git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
# 将本地当前分支 推送到 远程指定分支上
git push &lt;远程仓库名&gt; &lt;远程分支名&gt;
# 指定了origin所代表的远程仓库后
git push origin &lt;远程分支名&gt;
</code></pre>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422053325690.png" alt="image-20210422053325690" style="zoom: 67%;" />
<p>git分支中常用指令：</p>
<pre><code># 列出所有本地分支
git branch
# 列出所有远程分支
git branch -r
# 新建一个分支，但依然停留在当前分支
git branch [branch-name]
# 新建一个分支，并切换到该分支
git checkout -b [branch]
# 合并指定分支到当前分支
$ git merge [branch]
# 删除分支
$ git branch -d [branch-name]
# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
<p>Bash中操作</p>
<figure data-type="image" tabindex="23"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422053733351.png" alt="image-20210422053733351" loading="lazy"></figure>
<p>IDEA中操作</p>
<figure data-type="image" tabindex="24"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422054704671.png" alt="image-20210422054704671" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Git%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20210422054801337.png" alt="image-20210422054801337" loading="lazy"></figure>
<p>注意：</p>
<ul>
<li>
<p>如果同一个文件在合并分支时都被修改了则会引起冲突，解决的办法是我们可以修改冲突文件后重新提交，选择要保留他的代码还是你的代码。</p>
</li>
<li>
<p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
</li>
</ul>
<p>额外资料：<a href="https://gitee.com/all-about-git">Git命令大全</a>，<a href="https://oschina.gitee.io/learn-git-branching/">Git命令学习</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何零基础建立个人博客(Coding Page + Gridea + COSBrowser)]]></title>
        <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/ru-he-ling-ji-chu-jian-li-ge-ren-bo-ke-coding-page-gridea-cosbrowser/</id>
        <link href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/ru-he-ling-ji-chu-jian-li-ge-ren-bo-ke-coding-page-gridea-cosbrowser/">
        </link>
        <updated>2021-03-29T19:08:35.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇主要介绍<strong>如何以最低的学习成本制作一个完整的个人博客</strong>，无需了解前端</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇主要介绍<strong>如何以最低的学习成本制作一个完整的个人博客</strong>，无需了解前端</p>
<!-- more -->
<h1 id="前言">前言</h1>
<p>很多人会质疑都2021年了，有必要建个人博客吗，又没有人看。我个人认为，个人博客对于像我这样从其他领域转码的rookie来说，还是很有必要的，可以记录自己的一些经验，防止以后忘记，方便自我回顾。同时，自学转码的路上，光看视频或网课是远远不够的，必须要做实操项目，而实操项目和视频网课之间的鸿沟巨大，个人博客就是很好的一个过渡，可以巩固知识点，加深记忆和熟练掌握的程度。</p>
<h1 id="coding-page">Coding Page</h1>
<p><strong>Coding</strong>是一个提供代码托管和协作研发的工具网站，在建博客中的功能是托管博客网站的html代码，提供的原始博客网址称为Coding Page。网站本身类似<strong>Github</strong>和<strong>码云</strong>，三者选其一即可，各有优缺点</p>
<ul>
<li>Github Page在国内无法正常访问，需要VPN/SSR</li>
<li>码云的Gitee Page无法在后续所用到的Gridea软件上直接配置，需要通过编程批量替换Gridea的字符串，再批处理拉取远程仓库，更新文件（我用python写的脚本，但是pyinstaller需要python版本较低，我不想重装因此放弃）。在此贴出参考<a href="https://blog.csdn.net/ZXYhappiness/article/details/107564963">如何采用Gitee Pages + Gridea 搭建个人主页</a></li>
<li>Coding Page的域名不像Github和码云的page一样是以io结尾的固定域名，而是随机分配的，所以非常复杂，所以几乎必定得购买注册域名，例如本博客的原始Page域名是https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/markdown-yu-fa-da-quan/</li>
</ul>
<h2 id="coding-page配置"><strong>Coding Page配置</strong></h2>
<p>首先进入<a href="https://coding.net/">coding官网</a>点开右上角的登录/注册，选择免费注册。</p>
<p>第一行团队名称随意，第二行的<mark>团队域名</mark>请谨慎填写，在之后配置Gridea时会用到。</p>
<figure data-type="image" tabindex="1"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/1.png" alt="img" loading="lazy"></figure>
<p>随后点击下一步，进入创建用户阶段，选择邮箱注册，不要选微信注册，这里<mark>注册邮箱</mark>需要记录下来后续会用到</p>
<figure data-type="image" tabindex="2"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/2.png" alt="img" loading="lazy"></figure>
<p>下一步完成注册后回到登陆页面登录即可。登陆后流程如下所示：</p>
<ol>
<li>点击左侧项目，然后选择创建项目。</li>
</ol>
<p><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/3.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/4.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>我这里是已经创建好了项目kimtanyo</p>
<ol start="2">
<li>项目模板选择代码托管项目</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/5.png" alt="img" loading="lazy"></figure>
<p>填写项目名称、项目标识，其中<mark>项目标识</mark>请谨慎填写，在之后配置Gridea时会用到。</p>
<figure data-type="image" tabindex="4"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/6.png" alt="img" loading="lazy"></figure>
<p>弹出的邀请成员加入项目关掉即可，不用理会。</p>
<ol start="3">
<li>进入到新建的项目中，创建代码仓库（此处我已经创建了，仍为kimtanyo）</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/10.png" alt="img" loading="lazy"></figure>
<p>填写仓库名称创建，如果是从github或者码云的原博客想转过来，也可以选择<strong>导入外部仓库</strong></p>
<figure data-type="image" tabindex="6"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/11.png" alt="img" loading="lazy"></figure>
<ol start="4">
<li>在项目中，选择左下角的项目设置。</li>
</ol>
<figure data-type="image" tabindex="7"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/7.png" alt="img" loading="lazy"></figure>
<p>点击功能开关</p>
<figure data-type="image" tabindex="8"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/8.png" alt="" loading="lazy"></figure>
<p>打开持续部署和持续集成</p>
<figure data-type="image" tabindex="9"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/9.png" alt="" loading="lazy"></figure>
<ol start="5">
<li>此时可以看到左边菜单栏多出持续部署和持续集成选项，展开持续部署后选择<strong>网站托管</strong>，点击新建网站</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/12.png" alt="" loading="lazy"></figure>
<p>选择静态网站即可（因为后续所用的Gridea只能写静态博客）</p>
<figure data-type="image" tabindex="11"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/13.png" alt="" loading="lazy"></figure>
<p>网站名称随意，代码仓库选择刚刚新建的，分支选择默认的master，注意节点一定要选择香港，选大陆地区的话，涉及配置自定义域名时需要自行备案，如不备案，则会部署失败</p>
<p>等待几分钟网站部署好之后，进入部署好的网站，记录下来<mark>网站地址</mark>后续会用到</p>
<figure data-type="image" tabindex="12"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/14.png" alt="" loading="lazy"></figure>
<ol start="6">
<li>点击右上角的个人账户设置</li>
</ol>
<figure data-type="image" tabindex="13"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/16.png" alt="" loading="lazy"></figure>
<p>选择访问令牌——新建令牌，此处要记录<mark>令牌用户名</mark>，之后会用到</p>
<figure data-type="image" tabindex="14"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/17.png" alt="" loading="lazy"></figure>
<p>随意填写令牌描述，勾选第一项project:depot，完成创建，创建后会得到<mark>令牌</mark>，也需要记录下来</p>
<figure data-type="image" tabindex="15"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/18.png" alt="" loading="lazy"></figure>
<h1 id="gridea">Gridea</h1>
<p>简而言之，Gridea就是个静态博客写作客户端，帮助构建和管理博客或静态站点的工具。使用简单，支持Markdown语法，且windows/Mac OS/Linux全平台支持，这也是我选择它的理由之一。虽然目前还不支持云端同步，配合onedrive同步盘工具还是可以实现三平台无缝衔接。</p>
<p>不过通常我并不会直接在Gridea里面写博客，而是在Typora或其他Markdown写作工具上写好之后，再复制进去直接发布即可，因为Gridea里面的Markdown实时解析偶尔会卡顿显示不出图像，如果写了html代码在文章中，显示的排版也有点小问题，和实际发布后访问网站的结果不太一样。</p>
<h2 id="gridea配置">Gridea配置</h2>
<p>先去Gridea官网<a href="https://gridea.dev/">下载</a>并安装，而后选择<strong>远程</strong>中的Coding Pages，其中要填写的所有内容都在前面<mark>高亮标记</mark>出来了</p>
<figure data-type="image" tabindex="16"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/15.png" alt="" loading="lazy"></figure>
<p>域名：填写在coding配置中静态网站的访问地址</p>
<p>仓库名称：填写创建项目时填写的项目标识/项目标识，例如我的项目标识为kimtanyo，则填写kimtanyo/kimtanyo</p>
<p>分支：填写master即可</p>
<p>仓库用户名：填写注册coding账户时的团队域名</p>
<p>邮箱：填写注册coding账户时的邮箱</p>
<p>令牌用户名和令牌：个人账户设置中创建访问令牌时的令牌用户名和令牌</p>
<p>CNAME：这里先不填写即可，如果已经有了个人域名则输入个人域名，后面会讲</p>
<h2 id="gridea博客写作">Gridea博客写作</h2>
<p>Gridea配置好之后，首先需要给自己的博客设置一个主题，也就是一个模板</p>
<figure data-type="image" tabindex="17"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/19.png" alt="" loading="lazy"></figure>
<p>主题设置好之后可以点击左下角的预览打开本地文件，嫌麻烦也可以去官网查看并预览更多主题，此外还可以在自定义配置中设置名片和社交超链接，还可以设置网页的图标，也就是favicon.ico，还有主题中显示的个人头像</p>
<p>设置好之后点击同步，就可以更新到你的博客了，<strong>注意以后每次更改设置或者发布博客之后都要点击同步</strong>（即使是添加标签也算）</p>
<p>现在可以开始写博客了，点击文章——新建，把在typora里写好的文章复制到这里来，点击右上角保存即可</p>
<figure data-type="image" tabindex="18"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/20.png" alt="" loading="lazy"></figure>
<p>注意文章右侧的设置中，可以设置文章的URL、分类标签（需要提前在主界面先创建）以及封面图</p>
<figure data-type="image" tabindex="19"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/21.png" alt="" loading="lazy"></figure>
<p>封面图不要上传本地文件，一定要用外链，这里推荐把封面图上传到图床，再在此处使用链接（关于图床后面会说）</p>
<h2 id="gitalk评论配置"><strong>Gitalk评论配置</strong></h2>
<p>Gridea支持Gitalk和Disqus两种评论系统，这里我使用Gitalk评论系统。</p>
<p>首先你需要有一个 <strong>「GitHub OAuth Application」</strong> ，点击<a href="https://github.com/settings/applications/new">这里</a>创建</p>
<figure data-type="image" tabindex="20"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/28.png" alt="" loading="lazy"></figure>
<p>这里Homepage和Authorization callback的URL都填博客主页的域名，application name随意</p>
<p>设置完成后，会生成一个Client ID，需要自己手动创建一个Client Secret，这里先复制或者记录下来，在接下来的配置中使用。</p>
<figure data-type="image" tabindex="21"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/29.png" alt="" loading="lazy"></figure>
<p>创建用于存放评论的仓库，<strong>注意仓库名中间不允许空格，如果有空格会被默认替换成<code>-</code></strong></p>
<figure data-type="image" tabindex="22"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/31.png" alt="" loading="lazy"></figure>
<p><strong>注意检查新建的仓库有没有打开Issues栏，如果没有则要去仓库的Setting—Options—Features，勾上Issues</strong></p>
<p>回到Gridea的评论配置，依次填写即可</p>
<figure data-type="image" tabindex="23"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/32.png" alt="" loading="lazy"></figure>
<p>这里Owner即Github名</p>
<p>完成后点击同步，在博客网页的文章最下方就会出现评论栏（图中的大实话评论在本文最后）</p>
<figure data-type="image" tabindex="24"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/39.png" alt="" loading="lazy"></figure>
<p><em>注意：有部分帖子称会发生点击评论处的登录Github时，会跳转到博客首页，此时将刚刚创建的Application的Homepage和Authorization callback的URL都改成Coding Page的原始URL即可解决问题</em></p>
<h2 id="个人域名绑定">个人域名绑定</h2>
<p>此时其实已经可以通过coding中静态网站的访问地址，访问你的博客网站了</p>
<p>但是coding分配的域名没有规则，难以记忆，B格不高。这时候如果我们就可以花上一点小钱，买上一个域名，就可以拥有一个更加🐂🍺的体验。域名服务自己购买即可。这里最好还是选择腾讯云的服务，毕竟白嫖了人家的coding服务器，而且腾讯云的域名非常便宜。</p>
<p>点击腾讯云主页,注册登陆后搜索<strong>域名注册</strong>，购买域名，并完成实名制，这里就不详述过程了。</p>
<figure data-type="image" tabindex="25"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/22.png" alt="" loading="lazy"></figure>
<p>在Coding项目的静态网站中，选中自定义域名，点击新建域名，输入买的域名（<strong>前面要加上www</strong>）</p>
<figure data-type="image" tabindex="26"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/26.png" alt="" loading="lazy"></figure>
<p>此时先跳过证书的相关步骤，记下来这里的<mark>CNAME指向</mark></p>
<p>回到腾讯云——域名注册——我的域名，点击<strong>解析</strong></p>
<figure data-type="image" tabindex="27"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/23.png" alt="" loading="lazy"></figure>
<p>默认的两条记录不要进行删改，点击添加记录</p>
<figure data-type="image" tabindex="28"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/24.png" alt="" loading="lazy"></figure>
<p>第一条：主机记录www；记录类型CNAME；记录值填写CNAME指向的域名</p>
<p>第二条：主机记录@ ；记录类型A ；记录值：</p>
<p>Win+R打开cmd，输入ping+空格+CNAME指向的域名，例如</p>
<pre><code>ping www.kimtanyo.cloud.cdn.dnsv1.com
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/27.png" alt="" loading="lazy"></figure>
<p>记录值填写返回的数字ip地址即可，例如此处是18.166.25.109</p>
<p>然后我们点击这两条新建记录右侧的SSL，申请CA证书，等待几分钟通过</p>
<figure data-type="image" tabindex="30"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/25.png" alt="" loading="lazy"></figure>
<p>然后回到Coding重新检查证书颁发状态</p>
<figure data-type="image" tabindex="31"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/26.png" alt="" loading="lazy"></figure>
<p>最后进入Gridea填写自己的个人域名到CNAME中去，并点击同步</p>
<figure data-type="image" tabindex="32"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/15.png" alt="" loading="lazy"></figure>
<p>现在你可以访问你的个人域名来打开博客了</p>
<h1 id="cosbrowser">COSBrowser</h1>
<p>经常发博客的人可能会头疼，图片如果用本地的路径写入Markdown文本中，那只有自己才能看得到，别人打开博客是加载不出来的。</p>
<p>图床就是一个在网络上存储图片的地方，目的是为了节省本地服务器空间，将图片传到图床后，每张图片都会有自己的链接，即可写入Markdown中引用外链共享。</p>
<p>图床推荐<strong>腾讯云的COS对象存储</strong>，搭配官方的可视化界面工具<strong>COSBrowser</strong>，首次使用有很长的免费期，且收费也非常便宜，并且Coding也是腾讯的、域名也是腾讯的，就一条路到黑最方便了。</p>
<p>进入【对象存储】→【存储桶列表】→【创建存储桶】</p>
<p>这里所属地域要选择和你的网站同样地区（也就是香港），权限一定要选择公有读私有写</p>
<figure data-type="image" tabindex="33"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/33.png" alt="" loading="lazy"></figure>
<p>创建完毕后点击【密钥管理】→【云API密钥】→【新建密钥】</p>
<figure data-type="image" tabindex="34"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/34.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/35.png" alt="" loading="lazy"></figure>
<p>这里的SecretId和SecretKey要记录或复制下来</p>
<p>回到【对象存储】→【工具】→【客户端下载】，下载Windows版本的<strong>COSBrowser</strong></p>
<figure data-type="image" tabindex="36"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/36.png" alt="" loading="lazy"></figure>
<p>安装后用SecretId和SecretKey登录，其他不用填</p>
<figure data-type="image" tabindex="37"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/37.png" alt="" loading="lazy"></figure>
<p>打开新建的存储桶，尽量为每篇博客都新建一个文件夹分好类，写文章的时候，将需要用到的图片都拖动进来上传</p>
<figure data-type="image" tabindex="38"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/%E5%A6%82%E4%BD%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%28Coding%20Page%20%2B%20Gridea%20%2B%20COSBrowser%29/38.png" alt="" loading="lazy"></figure>
<p>相比COSBrowser，可能很多人用的是PicGo，因为泛用性强，可以兼容市面上几乎所有的图床，但是经常出毛病上传失败，所以如果你不是用的腾讯云的COS作为图床，那可以改用PicGo。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Excel嵌入式jupyter工具——Pyxll]]></title>
        <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/excel-qian-ru-shi-jupyter-gong-ju-pyxll/</id>
        <link href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/excel-qian-ru-shi-jupyter-gong-ju-pyxll/">
        </link>
        <updated>2021-01-23T16:09:13.000Z</updated>
        <summary type="html"><![CDATA[<p>Pyxll优势：比VBA方便调试，界面的用户交互性更好；比win32com语法和逻辑简单，可以内嵌在excel中开着表的同时使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>Pyxll优势：比VBA方便调试，界面的用户交互性更好；比win32com语法和逻辑简单，可以内嵌在excel中开着表的同时使用</p>
<!-- more -->
<h1 id="一-安装pyxll">一、安装Pyxll</h1>
<p><strong>1. 首先需要通过pip安装pyxll</strong></p>
<pre><code>pip install pyxll
</code></pre>
<p>到官网https://www.pyxll.com/index.html下载pyxll的excel内嵌插件</p>
<p>选择自己的python版本以及excel版本</p>
<p><mark><strong>注意python和excel必须同为32位或64位</strong></mark></p>
<p>私人电脑一般默认安装的都是32位的office</p>
<p>所以如果你装的是64位的python则必须在 <code>重装32位python</code>和<code>重装64位office</code>之中二选一</p>
<p>个人推荐重装office，因为python的重装还需要安装各种以前的第三方库，类似tensorflow或pytorch这种尤为复杂</p>
<p>网上搜索到的一般都是32位的office，这里给出64位office的下载地址<a href="http://ucff.cn/WenKu/Data/2016061917461560.html">http://ucff.cn/WenKu/Data/2016061917461560.html</a></p>
<p><mark><strong>注意不要从注册表更改默认安装位置</strong></mark>，否则下一步会识别不到excel的安装位置</p>
<figure data-type="image" tabindex="1"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Excel%E5%B5%8C%E5%85%A5%E5%BC%8Fjupyter%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Pyxll/2.png" alt="" loading="lazy"></figure>
<p><strong>2. 然后再用<code>PyXLL</code>的命令行工具安装Excel插件</strong></p>
<pre><code>pyxll install
</code></pre>
<p>注意选择一定要自行下载插件，输入下载的插件地址</p>
<p>如果遇到询问license，输入n即可</p>
<figure data-type="image" tabindex="2"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Excel%E5%B5%8C%E5%85%A5%E5%BC%8Fjupyter%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Pyxll/1.png" alt="" loading="lazy"></figure>
<p><strong>3. 使用pip安装<code>pyxll-jupyter</code>软件包：</strong></p>
<pre><code>pip install pyxll-jupyter
</code></pre>
<p>如果需要换镜像源加速，请使用清华镜像源https://pypi.tuna.tsinghua.edu.cn/simple，其他国内镜像目前没有（后续可能更新）</p>
<pre><code>pip install pyxll-jupyter -i https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<h1 id="二-使用方法">二、使用方法</h1>
<p>安装完毕后，启动Excel，将在<code>PyXLL</code>选项卡中看到一个新的<code>Jupyter</code>按钮</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2020122409371162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NTEwMjQ1,size_16,color_FFFFFF,t_70" alt="图片" loading="lazy"></figure>
<p>单击此按钮可在Excel工作簿的侧面板中打开Jupyter Notebook。该面板是Excel界面的一部分，可以通过拖放操作取消停靠或停靠在其他位置</p>
<p>在Jupyter面板中，你可以选择一个现有的Notebook或创建一个新的Notebook。创建一个新的Notebook，选择新建按钮，然后选择<code>Python 3</code></p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20201224093717155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NTEwMjQ1,size_16,color_FFFFFF,t_70" alt="图片" loading="lazy"></figure>
<p><strong>注意</strong>：</p>
<ol>
<li>每次alt+tab切屏回来，默认输入窗口都在表格页面，编辑jupyter需要点击它</li>
<li>jupyter默认在<code>我的文档</code>打开，只能在此处创建ipynb脚本</li>
<li>未保存情况下关闭excel会导致表格和jupyter同时未保存</li>
<li>保存需要分别选中表格和jupyter按两次<code>Ctrl+S</code></li>
</ol>
<h1 id="三-表格导入导出">三、表格导入导出</h1>
<h2 id="1-导入">1、导入</h2>
<p>因为PyXLL在与Excel相同的进程中运行Python，所以用Python访问Excel数据以及在Python和Excel之间快速调用。</p>
<p>为了使事情尽可能简单，<code>pyxll-jupyter</code>包附带了一些<code>IPython</code>“魔法”函数，可以在你的Jupyter笔记本中使用。</p>
<p><strong>1. 将表格导入python内存</strong></p>
<pre><code>%xl_get # 打印表
df =％xl_get # 将表赋值给名为df的DataFrame（不用import pandas）
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/NOM5HN2icXzxsWfQ4TOdv4yePnbjd9vocg3Lianhf9ibUOEMq0qBklibSB2NTuu8F6DxqibN08BqfB6sJicssSOO3v4g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" loading="lazy"></figure>
<p>excel sheet 与 Pandas DataFrames 同步</p>
<p>使用魔术函数<code>％xl_get</code>可以获取Python中<mark>当前的Excel框选区域</mark>，默认包含head行</p>
<p>选择左上角单独一个单元格的话，则读取整张表非空的部分</p>
<p><code>％xl_get</code>魔术函数有几个选项：</p>
<pre><code> -c或--cell。 传递单元格的地址以获取值，例如％xl_get --cell A1：D5
 -t或--type。 指定获取值时要使用的数据类型，例如％xl_get --type numpy_array
 -x或--no-auto-resize。 仅获取选定范围或给定范围的数据。 不要扩展到包括周围的数据范围
</code></pre>
<p>PyXLL还有其他与Excel交互以将数据读入Python的方式。 <code>％xl_get</code>魔术功能只是使事情变得更简单</p>
<p>当Jupyter笔记本在Excel中运行时，所有其他方法（例如，使用XLCell类，Excel的COM API甚至xlwings）仍然可用</p>
<h2 id="2-导出">2、导出</h2>
<p>从Python到Excel的另一种传输方式也可以正常工作。 无论你是使用Python加载数据集并将其传输到Excel工作簿，还是通过Excel处理数据集并希望将结果返回Excel，从Python复制数据到Excel都很容易。</p>
<pre><code>％xl_set df # 将格式为DataFrame的df写入表中
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20201224093737547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NTEwMjQ1,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"></figure>
<p>与<code>％xl_get</code>一样，<code>％xl_set</code>也具有一系列选项来控制其行为，你甚至可以使用PyXLL的单元格格式设置功能在将结果写入Excel的同时自动应用格式设置</p>
<pre><code>-c或--cell。将值写入单元格地址，例如％xl_set VALUE --cell A1
-t或--type。将值写入Excel时要使用的数据类型说明符，例如％xl_set VALUE --type dataframe &lt;index = False&gt;
-f或--formatter。 PyXLL单元格格式化程序对象，例如％xl_set VALUE --formatter DataFrameFormatter（）
-x或--no-auto-resize。不要自动调整范围大小以适合数据。仅将值写入当前选择或指定范围
</code></pre>
<p>格式化单元格DataFrameFormatter的参数请参阅https://www.pyxll.com/docs/userguide/formatting/index.html</p>
<p>与<code>％xl_get</code>一样，<code>％xl_set</code>只是一个快捷方式，所有其他写回Excel的方式仍然可以在Jupyter笔记本中使用</p>
<h1 id="四-在excel中直接绘图">四、在Excel中直接绘图</h1>
<p>在jupyter中进行数据处理的一大优点是可用的功能强大的绘图程序包， 例如df.plot()</p>
<p>PyXLL集成了所有主要的绘图库，因此你也可以在Excel中充分利用它们。 这包括matplotlib（由pandas使用），plotly，bokeh和altair</p>
<p>使用<code>%xl_plot</code>可以在在jupyter上画图的同时将图像输出到excel中</p>
<pre><code>%xl_plot FIGURE # 任意一个图形对象
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20201224093745551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NTEwMjQ1,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"></figure>
<p>使用<code>％xl_plot</code>可以在Excel中绘制任何Python图表。，从一个受支持的绘图库中向其传递任何图形对象，或一个pyplot图形，使用pandas plot的效果也很好，例如：</p>
<pre><code>%xl_plot df.plot(kind=‘scatter’)
</code></pre>
<p>％xl_plot魔术函数具有一些选项来控制其工作方式：</p>
<pre><code> -n或--name。 Excel中图片对象的名称。 如果使用已经存在的图片名称，则该图片将被替换
 -c或--cell。 用作新图片位置的单元格地址。 如果图片已经存在，则无效
 -w或--width。 Excel中图片的宽度（以磅为单位）。 如果更新现有图片，则无效
 -h或--height。 Excel中图片的高度（以磅为单位）。 如果更新现有图片，则无效
</code></pre>
<p>％xl_plot是pyxll.plot函数的快捷方式，也可以通过pyxll.plot()来绘制</p>
<h1 id="五-在excel调用自定义python函数">五、在Excel调用自定义Python函数</h1>
<p>你可以直接从Excel工作簿中调用Python函数，而不是在Excel和Jupyter之间不断移动数据然后运行一些Python代码</p>
<p>PyXLL的主要用例之一是用Python编写自定义Excel工作表函数（或<code>UDF</code>），这些函数可以使用其他Python库（例如pandas和scipy）</p>
<p>你也可以在Jupyter笔记本中编写Excel工作表函数。 这是在不离开Excel即可使用Python IDE的情况下尝试想法的绝佳方法。</p>
<p>例如下面，编写一个简单的函数，然后将“ pyxll.xl_func”修饰符添加到excel的函数中：</p>
<pre><code>from pyxll import xl_func

@xl_func
def test_func(a, b, c):
    # This function can be called from Excel!
    return (a * b) + c
</code></pre>
<p>输入代码并在Jupyter中运行单元格后，即可从Excel工作簿中打字调用Python函数，<mark>注意excel调用函数的时候，参数是和python定义的对应的</mark></p>
<p>不只是简单的功能，可以将整个数据范围作为pandas DataFrames传递给函数，并返回任何Python类型，包括numpy数组和DataFrames，你可以通过给@xl_func装饰器一个参数字符串，来指定这个函数期望的数据类型</p>
<p>例如，尝试以下方法：</p>
<pre><code>from pyxll import xl_func

# 装饰器签名告诉 PyXLL 如何转换函数参数和返回的值
@xl_func(&quot;dataframe df: dataframe&lt;index=True&gt;&quot;, auto_resize=True)
def df_describe(df):
    # df 是一个从数据集里创建的 pandas DataFrame 传递给函数
    desc = df.describe()
    
    # desc 是新的 DataFrame（PyXLL转换为一组值并返回给Excel所创建的）
    return desc
</code></pre>
<p>你可以编写复杂的Python函数来进行数据转换和分析，Excel中如何调用或排序这些函数。 更改输入会导致调用函数，并且计算出的输出会==<strong>实时更新</strong>==，这与你期望的一样</p>
<h1 id="六-在excel中使用python编写的宏">六、在Excel中使用Python编写的宏</h1>
<h2 id="1-python作为vba的替代品">1、Python作为VBA的替代品</h2>
<p>在VBA中可以执行的所有操作也可以在Python中完成，编写VBA时将使用Excel对象模型，但是Python也提供相同的API</p>
<p>在Excel中运行的Jupyter笔记本中，可以使用整个Excel对象模型，因此你可以使用与Excel VBA编辑器中完全相同的方式编写Excel脚本</p>
<p>由于PyXLL在Excel进程内运行Python，因此从Python调用Excel不会对性能造成任何影响。也可以从外部Python进程调用Excel，但这通常要慢得多，在Excel中运行Jupyter笔记本也使一切变得更加便捷</p>
<p>使用PyXLL的<code>xl_app</code>函数获取<code>Excel.Application</code>对象，该对象等效于VBA中的Application对象，尝试进行诸如获取当前选择和更改单元格内部颜色之类的操作，但是在Python中，我们是**<mark>显式获取当前的活动表</mark>**</p>
<p>弄清楚如何使用Excel对象模型进行操作的一种好方法是记录VBA宏，然后将该宏转换为Python。</p>
<p>PyXLL文档页面Python作为VBA的替代品提供了一些有关如何做到这一点的技巧，详情可参阅https://www.pyxll.com/docs/userguide/vba.html</p>
<p>例如下方的更改选定区域单元格颜色</p>
<pre><code>from pyxll import xl_app
xl = xl_app()
xl.Selection.Interior.Color = 0xff00ff
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20201224093758979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NTEwMjQ1,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"></figure>
<h2 id="2-python的宏功能">2、Python的宏功能</h2>
<p>你可以在python中编写一个Excel宏，以执行以前使用VBA所做的任何事情。宏的工作方式与工作表功能非常相似。要将函数注册为宏，请使用@<code>xl_macro</code>装饰器</p>
<h3 id="将python函数设定为宏">将Python函数设定为宏</h3>
<p>IPython的魔法函数<code>@xl_macro</code>可以作为装饰器修饰需要设定为宏的函数</p>
<pre><code>from pyxll import xl_macro, xl_app, xlcAlert

@xl_macro
def popup_messagebox():
    xlcAlert(&quot;Hello&quot;) # 弹窗提示Hello

@xl_macro
def set_current_cell(value):
    xl = xl_app()
    xl.Selection.Value = value

@xl_macro(&quot;string n: int&quot;) # 设定期望数据类型
def py_strlen(n):
    return len(x)
</code></pre>
<p>例如下方，实现选中B11到K11的功能</p>
<pre><code>from pyxll import xl_macro, xl_app


@xl_macro
def macro1():
    xl = xl_app()

    # 'xl' is an instance of the Excel.Application object

    # Get the current ActiveSheet (same as in VBA)
    sheet = xl.ActiveSheet

    # Call the 'Range' method on the Sheet
    xl_range = sheet.Range('B11:K11')

    # Call the 'Select' method on the Range.
    # Note the parentheses which are not required in VBA but are in Python.
    xl_range.Select()
</code></pre>
<h3 id="键盘快捷键">键盘快捷键</h3>
<p>您可以通过使用<code>@xl_macro</code>装饰器的<code>shortcut</code>关键字参数，或编辑Pyxll安装文件夹下的pyxll.cfg配置文件，在<em>SHORTCUTS</em>部分中进行设置，将键盘快捷键分配给宏</p>
<p>快捷键应为一个或多个修饰键名称（<em>Ctrl</em>，<em>Shift</em>或<em>Alt</em>）和一个键，并以'+'符号分隔。例如，“ Ctrl + Shift + R”。</p>
<pre><code>from pyxll import xl_macro, xl_app

@xl_macro(shortcut=&quot;Alt+F3&quot;)
def macro_with_shortcut():
    xlcAlert(&quot;Alt+F3 pressed&quot;)
</code></pre>
<p>如果Excel已经使用了组合键，则可能无法为该组合键分配宏</p>
<p>除字母，数字和功能键外，还可以使用以下特殊键（它们不区分大小写）</p>
<ul>
<li>Backspace</li>
<li>Break</li>
<li>CapsLock</li>
<li>Clear</li>
<li>Delete</li>
<li>Down</li>
<li>End</li>
<li>Enter</li>
<li>Escape</li>
<li>Home</li>
<li>Insert</li>
<li>Left</li>
<li>NumLock</li>
<li>PgDn</li>
<li>PgUp</li>
<li>Right</li>
<li>ScrollLock</li>
<li>Tab</li>
</ul>
<h3 id="从excel调用宏">从Excel调用宏</h3>
<p>与其他Excel宏一样，可以从Excel调用用PyXLL定义的宏。</p>
<p>最常用的方法是将宏分配给控件。为此，首先通过转到Excel中的<code>开发工具</code>菜单来选中<code>插入</code>工具箱，然后选中<code>表单控件</code>中的任意一个，创建一个控件按钮</p>
<figure data-type="image" tabindex="9"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Excel%E5%B5%8C%E5%85%A5%E5%BC%8Fjupyter%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Pyxll/3.png" alt="" loading="lazy"></figure>
<p>然后右键单击按钮并选择<code>指定宏</code>。输入宏的名称，在本例中为<em>popup_messagebox</em>。现在，当您单击该按钮时，将调用该宏。</p>
<figure data-type="image" tabindex="10"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Excel%E5%B5%8C%E5%85%A5%E5%BC%8Fjupyter%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Pyxll/4.png" alt="" loading="lazy"></figure>
<p><mark>Excel中的<code>指定宏</code>对话框将仅列出工作簿中定义的宏。在Python中使用<code>@xl_macro</code>定义的任何宏都不会显示在此列表中。相反，你必须手动输入宏的名称，Excel会接受它</mark></p>
<blockquote>
<p>关于Pyxll的更多细微功能请参考官网文档https://www.pyxll.com/docs/userguide/udfs/index.html</p>
<p>日后可能再补充更新一些常用的表格编辑功能</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jupyter Lab基础使用与插件扩展]]></title>
        <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/jupyter-lab-ji-chu-shi-yong-yu-cha-jian-kuo-zhan/</id>
        <link href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/jupyter-lab-ji-chu-shi-yong-yu-cha-jian-kuo-zhan/">
        </link>
        <updated>2020-08-26T03:23:55.000Z</updated>
        <summary type="html"><![CDATA[<p>比Notebook界面友好，功能升级得也更加完善，且向下兼容Notebook</p>
]]></summary>
        <content type="html"><![CDATA[<p>比Notebook界面友好，功能升级得也更加完善，且向下兼容Notebook</p>
<!-- more -->
<h1 id="一-安装及设置右键菜单">一、安装及设置右键菜单</h1>
<p>与Jupyter Notebook相仿，通过pip安装</p>
<pre><code class="language-shell">pip install jupyterlab
</code></pre>
<p>为了使其更像一个IDE的打开方式，我们设置通过右键菜单<code>Jupyter Lab Here</code>打开，方法如下：</p>
<ul>
<li>新建注册表文件<code>Jupyter Lab Here.reg</code>，内容：</li>
</ul>
<pre><code class="language-shell">Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\directory\background\shell\Jupyter Lab Here]
&quot;icon&quot;=&quot;C:\\Users\\xxxx\\python\\3.6.8\\Lib\\site-packages\\notebook\\static\\favicon.ico&quot;

[HKEY_CLASSES_ROOT\directory\background\shell\Jupyter Lab Here\command]
@=&quot;C:\\Users\\xxxx\\python\\3.6.8\\Scripts\\jupyter-lab.exe&quot;
</code></pre>
<blockquote>
<p>其中<code>favicon.ico</code>,<code>jupyter-lab.exe</code>的路径按实际情况修改</p>
</blockquote>
<ul>
<li>双击<code>Jupyter Lab Here.reg</code>文件，注入注册表即可</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95.png" alt="" loading="lazy"></figure>
<h1 id="二-基础使用">二、基础使用</h1>
<p><strong>由于Lab是Notebook的升级版，原本Notebook就有的功能就在此不再提及</strong></p>
<p><em>注意：其中用到的插件均在标题中指出，具体安装方法参考<code>三、插件扩展</code></em></p>
<h2 id="1-csv文件显示格式">1. csv文件显示格式</h2>
<p>在Notebook中，csv文件能直接打开但是会显示分隔符，跟记事本打开显示格式一样，不便查看</p>
<p>而在Lab中，这个问题得到了解决，Lab会自动判断分隔符并单独标注出，显示格式与excel中一样</p>
<figure data-type="image" tabindex="2"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/csv.png" alt="" loading="lazy"></figure>
<h2 id="2-pdf预览">2. pdf预览</h2>
<p>Notebook中原本无法预览pdf，打开pdf会自动下载，而在Lab中直接点击pdf可以很方便地在Lab的子窗口中打开预览pdf</p>
<figure data-type="image" tabindex="3"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/pdf.png" alt="" loading="lazy"></figure>
<h2 id="3-多窗口自由排布">3. 多窗口自由排布</h2>
<p>较之Notebook，对写代码体验改善最大的一点在于，可以进行多窗口的自由排布，cell可拖拽移动</p>
<p><mark>cell的output也可以单独拖动出新窗口，还可以随时开启终端交互</mark></p>
<figure data-type="image" tabindex="4"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/%E5%A4%9A%E7%AA%97%E5%8F%A3%E8%87%AA%E7%94%B1%E6%8E%92%E5%B8%83.png" alt="" loading="lazy"></figure>
<h2 id="4-代码提示">4. 代码提示</h2>
<p>Notebook相比pycharm这样的IDE最明显的一点就是，缺少代码提示，有时非常不方便，而Lab完善了这一功能</p>
<figure data-type="image" tabindex="5"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8.png" alt="" loading="lazy"></figure>
<h2 id="5-绘图插件jupyterlab-drawio">5. 绘图（插件jupyterlab-drawio）</h2>
<p>在论文写作过程中常常需要绘制简单的流程图或示意图，需要求助于visio等专业绘图软件，而论文中的大部分简单绘图在Lab上可以通过内置的绘图工具来完成</p>
<figure data-type="image" tabindex="6"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/%E7%BB%98%E5%9B%BE.png" alt="" loading="lazy"></figure>
<h2 id="6-tex编辑与编译预览插件jupyterlab-latex">6. Tex编辑与编译预览（插件jupyterlab-latex）</h2>
<p>原本的Notebook虽然可以打开tex文件查看代码进行编辑，但是无法编译预览tex文件，而在Lab中这项功能得到了实现</p>
<p>打开tex文件，在任意一处右键，点击<code>Show LaTex Preview</code>即可编译预览</p>
<p><em>注意：Lab的Tex默认编译器不支持中文</em></p>
<figure data-type="image" tabindex="7"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/latex.png" alt="" loading="lazy"></figure>
<h2 id="7-html网页浏览插件jupyterlab_html">7. HTML网页浏览（插件jupyterlab_html）</h2>
<p>Lab的这项功能在需要网页呈现动态可视化效果时非常有用</p>
<img src="https://raw.githubusercontent.com/mflevine/jupyterlab_html/master/docs/example1.gif" alt="Example GIF" style="max-width:100%;">
<h2 id="8-即时查看变量及属性插件jupyterlab_variableinspector">8. 即时查看变量及属性（插件jupyterlab_variableinspector）</h2>
<p>用过Matlab的人相比很怀念的一个功能就是，可以在菜单中随时查看变量的属性和值的变化，而Lab中同样可以做到</p>
<p><em>注意：需要先安装<code>jupyterlab-manager</code>和<code>ipywidgets</code></em></p>
<img src="https://github.com/lckr/jupyterlab-variableInspector/raw/master/early_demo.gif" alt="Demogif" style="max-width:100%;">
<h2 id="9-查看excel表格插件jupyterlab-spreadsheet">9. 查看excel表格（插件jupyterlab-spreadsheet）</h2>
<p>Lab可以打开显示XLS, XLSX, ODS表格，但是仅只读模式</p>
<img src="https://github.com/quigleyj97/jupyterlab-spreadsheet/raw/main/screenshot.png" alt="Image depicting the plugin displaying a simple XLS workbook" style="max-width:100%;">
<h1 id="三-插件扩展">三、插件扩展</h1>
<h2 id="1-设置插件栏">1. 设置插件栏</h2>
<p>在Lab中安装插件与Notebook一样，只需要在插件栏点击即可安装，但是需要经过一点简单设置，因为<strong>插件栏默认不显示</strong></p>
<ol>
<li>点击菜单栏<code>Settings</code>下拉框中的Advanced Settings Editor选项，会出现一个设置页面。</li>
<li>接着，点击<code>Extension Manager</code>，并且在<code>User Preferences</code>的空白框里填上<code>{'enabled':true}</code>，并且按右上角的保存按钮。</li>
<li>然后最左侧最下方就多出了一个插件栏</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/%E6%8F%92%E4%BB%B6%E6%A0%8F%E8%AE%BE%E7%BD%AE.png" alt="" loading="lazy"></figure>
<p>与Notebook不同的是，Notebook光列出所有的插件名称不显示功能，而Lab不仅有一行简单的功能介绍，还显示了所有的插件github主页链接，可以点击查看插件的详细用法</p>
<p><mark>此外如果server报错Error: 500则可以在github上搜索插件全名，自行安装</mark></p>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Jupyter%20Lab%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/error.png" style="zoom:80%;" />
<h2 id="2-插件推荐">2. 插件推荐</h2>
<h3 id="1-jupyterlab-github">1. jupyterlab-github</h3>
<p>安装这个插件后，Lab左侧会出现一个github栏按钮，你可以在里面搜索github项目，并且打开项目里面的文件，如果是notebook文件，能够直接运行代码</p>
<p><em>这个插件非常适合在Lab上学习github项目，方便高效</em></p>
<img src="https://github.com/jupyterlab/jupyterlab-github/raw/master/gitception.png" alt="gitception" title="Gitception" style="max-width:100%;">
<h3 id="2-jupyterlab-toc">2. jupyterlab-toc</h3>
<p>这是一个Lab的目录插件，安装后就能很方便地在Lab上展示notebook或者markdown的目录<br>
目录可以滚动，并且能展示或隐藏子目录</p>
<img src="https://github.com/jupyterlab/jupyterlab-toc/raw/master/toc.gif" alt="Table of Contents" title="Table of Contents" style="max-width:100%;">
<h3 id="3-ipympl">3. ipympl</h3>
<p>ipympl是matplotlib的插件，可以启用matplotlib的可视化交互功能，是插件中少数几个需要通过pip安装的</p>
<pre><code class="language-shell">pip install ipympl
</code></pre>
<p>且需要通过magic命令声明启用</p>
<pre><code class="language-python">%matplotlib widget
</code></pre>
<img src="https://github.com/matplotlib/ipympl/raw/master/matplotlib.gif" alt="matplotlib screencast" style="max-width:100%;">
<h3 id="4-nbgather">4. nbgather</h3>
<p>在Lab中清理代码，恢复丢失的代码以及比较代码版本的工具</p>
<img src="https://github.com/microsoft/gather/raw/master/docs/demo.gif" alt="Code gathering tools can help you clean your code and review versions of results." style="max-width:100%;">
<h3 id="5-jupyterlab_go_to_definition">5. jupyterlab_go_to_definition</h3>
<p>该插件用于在Lab笔记本和文件编辑器中跳转到变量或函数的定义，按住<code>Alt</code>+<code>LeftClick</code>对应变量或函数即可跳转</p>
<img src="https://raw.githubusercontent.com/krassowski/jupyterlab-go-to-definition/master/examples/demo.gif" alt="Go to definition" style="max-width:100%;">
<h3 id="6-jupyter-lsp">6. jupyter-lsp</h3>
<p>该插件用于<mark>自动补全、参数建议、函数文档查询、跳转定义</mark>等</p>
<p><strong>该插件不仅需要通过插件栏安装，也需要通过pip安装</strong></p>
<pre><code class="language-shell">pip install jupyter-lsp
</code></pre>
<img src="https://raw.githubusercontent.com/krassowski/jupyterlab-lsp/master/examples/screenshots/signature.png" alt="signature" style="max-width:100%;">
<img src="https://raw.githubusercontent.com/krassowski/jupyterlab-lsp/master/examples/screenshots/autocompletion.png" alt="autocompletion" style="max-width:100%;">
<p>同时，该插件还有类似pycharm的检查纠错功能</p>
<img src="https://raw.githubusercontent.com/krassowski/jupyterlab-lsp/master/examples/screenshots/inspections.png" alt="inspections" style="max-width:100%;">
<img src="https://raw.githubusercontent.com/krassowski/jupyterlab-lsp/master/examples/screenshots/panel.png" alt="panel" style="max-width:100%;">]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github下载缓慢及图片无法加载的解决方案（翻墙无效）]]></title>
        <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/github-fang-wen-huan-man-tu-pian-wu-fa-jia-zai-jie-jue-fang-an/</id>
        <link href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/github-fang-wen-huan-man-tu-pian-wu-fa-jia-zai-jie-jue-fang-an/">
        </link>
        <updated>2020-07-30T12:57:08.000Z</updated>
        <summary type="html"><![CDATA[<p>两种方法 ——主要记录油猴插件地址和完整版的dns解析地址</p>
]]></summary>
        <content type="html"><![CDATA[<p>两种方法 ——主要记录油猴插件地址和完整版的dns解析地址</p>
<!-- more -->
<h1 id="推荐法一油猴github镜像脚本插件">(推荐)法一：油猴github镜像脚本插件</h1>
<h2 id="一-下载脚本插件管理器">一、下载脚本插件管理器</h2>
<p>在油猴官网<a href="https://greasyfork.org/zh-CN">https://greasyfork.org/zh-CN</a>下载一个脚本插件管理器<br>
*推荐Chrome + Tampermonkey *<br>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Github%E8%AE%BF%E9%97%AE%E7%BC%93%E6%85%A2%E5%8F%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/GreasyFork.png" alt="" loading="lazy"></p>
<center>
    GreasyFork
</center>
<h2 id="二-下载github镜像插件">二、下载github镜像插件</h2>
<p>插件下载地址：<a href="https://greasyfork.org/zh-CN/scripts/397419-github%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AE-%E5%85%8B%E9%9A%86%E5%92%8C%E4%B8%8B%E8%BD%BD">https://greasyfork.org/zh-CN/scripts/397419-github镜像加速访问-克隆和下载</a><br>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Github%E8%AE%BF%E9%97%AE%E7%BC%93%E6%85%A2%E5%8F%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/github%E9%95%9C%E5%83%8F%E6%8F%92%E4%BB%B6.png" alt="" loading="lazy"></p>
<center>
   Github镜像插件
</center>
<p>安装完成后在<a href="https://github.com/RC1844/FastGithub">https://github.com/RC1844/FastGithub</a>上展示的github镜像站中按需选择镜像<br>
<mark><strong>注意不要拿自己账号登录镜像站</strong></mark><br>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Github%E8%AE%BF%E9%97%AE%E7%BC%93%E6%85%A2%E5%8F%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/github%E9%95%9C%E5%83%8F%E7%AB%99%E7%82%B9.png" alt="" loading="lazy"></p>
<center>
   Github镜像站点
</center>
<p>然后在镜像站中搜索仓名 或 直接在镜像域名后加上<code>/用户名/仓名</code>跳转，下载或克隆所需即可<br>
<mark>此处以<a href="https://github.wuyanzheshui.workers.dev">https://github.wuyanzheshui.workers.dev</a>和PicGo的图床releases下载为例</mark><br>
<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Github%E8%AE%BF%E9%97%AE%E7%BC%93%E6%85%A2%E5%8F%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%9F%9F%E5%90%8D%E4%BF%AE%E6%94%B9.png" alt="" loading="lazy"></p>
<h1 id="法二更改默认dns">法二：更改默认DNS</h1>
<p>只想要hosts修改结果的，请直接移步<a href="#1">此处</a></p>
<h2 id="一-获取github官方cdn地址">一、获取GitHub官方CDN地址</h2>
<p>打开 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a><br>
查询以下链接的地址</p>
<pre><code class="language-undefined">github.com
gist.github.com
assets-cdn.github.com
github.global.ssl.fastly.net

cloud.githubusercontent.com（注意这条Domain的IP会重复用到）
</code></pre>
<div align="center">
	<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Github%E8%AE%BF%E9%97%AE%E7%BC%93%E6%85%A2%E5%8F%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/GithubDNS.png"/>
    <div align="center">
    	Github官方CDN地址
    </div>
</div>
记录下查询到的ip地址
<h3 id="span-id1二-修改系统hosts文件span"><span id="1">二、修改系统Hosts文件</span></h3>
<p>用记事本打开系统hosts文件(需管理员权限)<br>
路径：C:\Windows\System32\drivers\etc<br>
在<mark>记事本末尾添加</mark><code>IP地址 域名</code>并保存。(需管理员权限，注意IP地址与域名间需留有空格)<br>
不必按照我下面的完全复制，github可能随时间更换ip地址，尽量按照自己查询到的为准<br>
<strong>注意不要删掉或覆盖原本的hosts内容</strong></p>
<pre><code class="language-undefined">140.82.114.3 github.com
140.82.112.4 gist.github.com
185.199.108.153 assets-cdn.github.com
199.232.69.194 github.global.ssl.fastly.net

（以下所有子域名的Domain都是githubusercontent.com，故ip完全一致不用重复查询）
199.232.68.133 cloud.githubusercontent.com
199.232.68.133 camo.githubusercontent.com
199.232.68.133 raw.githubusercontent.com
199.232.68.133 gist.githubusercontent.com
199.232.68.133 avatars0.githubusercontent.com
199.232.28.133 avatars1.githubusercontent.com
199.232.28.133 avatars2.githubusercontent.com
199.232.68.133 avatars3.githubusercontent.com
199.232.68.133 avatars4.githubusercontent.com
199.232.68.133 avatars5.githubusercontent.com
199.232.68.133 avatars6.githubusercontent.com
199.232.68.133 avatars7.githubusercontent.com
199.232.68.133 avatars8.githubusercontent.com
</code></pre>
<h2 id="三-刷新系统dns缓存">三、刷新系统DNS缓存</h2>
<p>win + R 打开命令行或 win + X 打开powershell<br>
输入并运行 ipconfig /flushdns 手动刷新系统DNS缓存</p>
<div align="center">
	<img src="https://picgallery-1257216000.cos.ap-hongkong.myqcloud.com/Github%E8%AE%BF%E9%97%AE%E7%BC%93%E6%85%A2%E5%8F%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/cmd.png"/>
    <div align="center">
    	刷新系统DNS缓存
    </div>
</div>
现在尝试重新clone和刷新页面，clone速度应当一定程度上提高了，图片可以加载出来。
<h2 id="四-如果无效提速不够">四、如果无效/提速不够</h2>
<p>以上方法不太可能完全无效，但如果觉得速度还是太慢，尝试打开SSR或者VPN的全局模式代理，工具推荐环日+ShadowsocksR，或者XShell+Vultr。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法大全(个人总结版 for Typora)]]></title>
        <id>https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/markdown-yu-fa-da-quan/</id>
        <link href="https://coding-pages-bucket-3541328-8521428-15072-548659-1257216000.cos-website.ap-hongkong.myqcloud.com/post/markdown-yu-fa-da-quan/">
        </link>
        <updated>2020-07-30T11:45:54.000Z</updated>
        <summary type="html"><![CDATA[<p>Markdown 是一种「电子邮件」风格的「标记语言」，最近写小说的时候受不了垃圾word，改用typora，顺道学了一下markdown的语法</p>
]]></summary>
        <content type="html"><![CDATA[<p>Markdown 是一种「电子邮件」风格的「标记语言」，最近写小说的时候受不了垃圾word，改用typora，顺道学了一下markdown的语法</p>
<!-- more -->
<blockquote>
<p>前言：最初接触到markdown是在notepad++和从dropbox的paper中，发现这种写作格式不用排版且可读性极强，并且作为纯文本兼容性极强，可以用任何文本编辑器打开，还可以完美转换为 Word、PDF、HTML、Latex等格式。<br>
 <br>
Note：如果你接触过Latex和Lyx，那么你一定会爱上Markdown的语法，在我看来Markdown可以粗略认为是介于Lyx和Latex之间的一种格式，自由度、美观性、排版效率介于二者之间，不需要像Latex那样引用一大堆的package才能达到很好看的效果，也不像Lyx一样自由度过低，效率高但美观不足，同时Markdown的编译用时几乎可以忽略。</p>
</blockquote>
<h2 id="span-id1一-概述span"><span id="1">一、概述</span></h2>
<h3 id="11-常见误解纠正">1.1 常见误解纠正</h3>
<ul>
<li>Markdown 发布的成品是完全由标点符号标签组成的纯文本。</li>
<li>Markdown 不限制编辑器，只是一种文本格式。</li>
</ul>
<h3 id="12-推荐markdown编辑器">1.2 推荐Markdown编辑器</h3>
<ul>
<li>常见的专业Markdown编辑器<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>有RoamResearch，Obsidian，Remnote，Typora等。</li>
<li>上述编辑器各有优劣，由于篇幅原因，详细对比请移步<a href="https://zhuanlan.zhihu.com/p/149401362">Denie的知乎专栏</a>查看，在此仅列出受诟病最多的缺点。
<ul>
<li>RoamResearch 收费15$/月</li>
<li>Obsidian 没有大纲和云存储</li>
<li>Remnote 没有Graph View</li>
<li>Typora 只支持标题级别的引用</li>
</ul>
</li>
<li>各位可视情况酌情使用，个人相对推荐Typora。</li>
</ul>
<h3 id="13-可扩展-html-语法">1.3 可扩展 HTML 语法</h3>
<ul>
<li>HTML 是一种<strong>发布格式</strong>，等同于pdf、tex、docx文件。</li>
<li>Markdown 是一种<strong>创作格式</strong>，等同于latex语法(但简单得多)。</li>
<li>Markdown 语法集合是HTML标签的一个子集。</li>
<li>对于 Markdown 中未包含的标签, 可以直接使用 HTML标签，例如用 HTML <code>&lt;span&gt;</code> 标签替代 Markdown 的链接语法。</li>
</ul>
<h3 id="14-特殊字符转义">1.4 特殊字符转义</h3>
<p>在 HTML 中, 有两个字符需要特殊对待: &lt; 和 &amp;，左尖括号用于起始标签。如果你想将它们用作字面量, 你必须将它们转义为字符实体, 例如<code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<h2 id="二-行内语法讲解">二、行内语法讲解</h2>
<h3 id="21-注释的表述">2.1 注释的表述</h3>
<ul>
<li><strong>代码法</strong></li>
</ul>
<pre><code class="language-xml">&lt;div style='display: none'&gt;
哈哈我是注释，不会在浏览器中显示。
&lt;/div&gt;
</code></pre>
<ul>
<li><strong>html注释</strong>(推荐)</li>
</ul>
<p>既然支持html语法，那也支持html注释，这也是Typora的默认注释方式。</p>
<pre><code class="language-xml">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;

&lt;!--
哈哈我是多段注释，
不会在浏览器中显示。
    --&gt;
</code></pre>
<ul>
<li><strong>hack方法</strong></li>
</ul>
<p>hack方法就是利用markdown的解析原理来实现注释的。<br>
一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。<br>
hack方法比上面2种方法稳定得多，但是语义化太差。</p>
<pre><code class="language-csharp">[//]: # (哈哈我是最强注释，不会在浏览器中显示。)
[^_^]: # (哈哈我是最萌注释，不会在浏览器中显示。)
[//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)
[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)
</code></pre>
<h3 id="22-分级标题-任务列表">2.2 分级标题、任务列表</h3>
<ul>
<li><strong>分级标题</strong></li>
</ul>
<p>注意#后面的空格</p>
<pre><code class="language-xml"># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题  &lt;!--最多6级标题--&gt;
</code></pre>
<p>由于用了标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。可以自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p>
<ul>
<li><strong>任务列表</strong></li>
</ul>
<p>Markdown 语法：</p>
<pre><code class="language-css">- [ ] 任务一 未做任务 `- + 空格 + [ ]`
- [x] 任务二 已做任务 `- + 空格 + [x]`
</code></pre>
<p>效果如下：</p>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1700617"> 任务一 未做任务 <label class="task-list-item-label" for="task-item-1700617"> 任务一 未做任务 `- + 空格 + [ ]`</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-9227373"> 任务二 已做任务 <label class="task-list-item-label" for="task-item-9227373"> 任务二 已做任务 `- + 空格 + [x]`</label></p>
</li>
</ul>
<h3 id="23-缩进-换行-空行-对齐方式">2.3 缩进、换行、空行、对齐方式</h3>
<ul>
<li><strong>首行缩进</strong></li>
</ul>
<p>不同特殊占位符所占空白是不一样大的。</p>
<pre><code class="language-bash">【1】 &amp;emsp;或&amp;#8195; //全角
【2】 &amp;ensp;或&amp;#8194; //半角
【3】 &amp;nbsp;或&amp;#160;  //半角之半角
</code></pre>
<ul>
<li><strong>换行</strong></li>
</ul>
<p>由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在Visual Studio Code上，想要<strong>换行必须得在一行字后面空两个格子才行</strong>。</p>
<ul>
<li><strong>空行</strong></li>
</ul>
<p>在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，在<strong>渲染之后，只隔着一行</strong>。</p>
<ul>
<li><strong>对齐方式</strong></li>
</ul>
<p>代码：</p>
<pre><code class="language-xml">&lt;center&gt;行中心对齐&lt;/center&gt;
&lt;p align=&quot;left&quot;&gt;行左对齐&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;行右对齐&lt;/p&gt;
</code></pre>
<p>显示效果：</p>
<center>行中心对齐</center>
 <p align="left">行左对齐</p>
 <p align="right">行右对齐</p>
<h3 id="24-斜体-粗体-删除线-下划线-背景高亮">2.4 斜体、粗体、删除线、下划线、背景高亮</h3>
<ul>
<li>代码：</li>
</ul>
<pre><code class="language-undefined">*斜体*或_斜体_
**粗体**
***加粗斜体***
~~删除线~~
&lt;u&gt;下划线&lt;/u&gt;
==背景高亮==
</code></pre>
<ul>
<li>显示效果：</li>
</ul>
<p><em>斜体</em>    <strong>粗体</strong>   *<strong>加粗斜体*</strong>   <s>删除线</s>   <u>下划线</u>   <mark>背景高亮</mark></p>
<h3 id="25-超链接-页内链接-自动链接-注脚">2.5 超链接、页内链接、自动链接、注脚</h3>
<ul>
<li><strong>行内式</strong></li>
</ul>
<p>语法说明：</p>
<p>[]里写链接文字，()里写链接地址, ()中的&quot;&quot;中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字，链接地址与title前有一个空格。（<mark>按住Ctrl + LeftClick可以访问超链接</mark>）</p>
<p>注意在网页前必须要加<code>http://</code>，如果不加<code>http://</code>，表示直接访问本地目录文件</p>
<p>代码：</p>
<pre><code class="language-bash">欢迎阅读[Kimtanyo的个人博客](https://kimtanyo.github.io &quot;kimtanyo blog&quot;)
内容我保存为了[本地文件](D:/自我鉴定.docx)
</code></pre>
<p>显示效果：</p>
<p>欢迎阅读 <a href="https://kimtanyo.github.io" title="kimtanyo blog">Kimtanyo的个人博客</a></p>
<p>内容我保存为了<a href="D:/%E8%87%AA%E6%88%91%E9%89%B4%E5%AE%9A.docx">本地文件</a></p>
<ul>
<li><strong>参考式</strong></li>
</ul>
<p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>
<p>语法说明：<br>
参考式链接分为两部分，文中的写法 <code>[链接文字][链接标记]</code>，在文本的任意位置添加<code>[链接标记]:链接地址</code>。</p>
<p>如果链接文字本身可以做为链接标记，你也可以写成<code>[链接文字][]</code><br>
<code>[链接文字]:链接地址</code>的形式，见代码的最后一行。</p>
<p>代码：</p>
<pre><code class="language-ruby">我经常去的几个网站[Google][1]、[Leanote][2]。

[1]:http://www.google.com 
[2]:http://www.leanote.com
</code></pre>
<p>显示效果：</p>
<p>我经常去的几个网站<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.google.com">Google</a>、<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.leanote.com">Leanote</a>。</p>
<ul>
<li><strong>注脚</strong></li>
</ul>
<p>语法说明：</p>
<p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试<mark>注脚与注脚之间必须空一行</mark>，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会<mark>自动归类到文章的最后</mark>。</p>
<p>代码：</p>
<pre><code class="language-css">使用 Markdown[^2]可以效率的书写文档, 直接转换成 HTML[^3]。

[^2]:Markdown是一种纯文本标记语言

[^3]:HyperText Markup Language 超文本标记语言
</code></pre>
<p>显示效果：</p>
<p>使用 Markdown<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>可以效率的书写文档, 直接转换成 HTML<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。</p>
<p>注：脚注自动被搬运到最后面，请到文章末尾查看，脚注后方的链接可以直接跳转回到加注的地方。</p>
<ul>
<li><strong>锚点（页内超链接）</strong></li>
</ul>
<p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的，Typora只支持在标题后插入锚点，其它地方无效。</p>
<p>代码：</p>
<pre><code class="language-css">## &lt;span id=&quot;1&quot;&gt;一、概述&lt;/span&gt;

跳转到[概述](#1)
</code></pre>
<p>显示效果：</p>
<p>跳转到<a href="#1">概述</a></p>
<ul>
<li><strong>自动链接</strong></li>
</ul>
<p>语法说明：<br>
Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<p>代码：</p>
<pre><code class="language-dart">&amp;lt;http://example.com/ &amp;gt;
&amp;lt;address@example.com&amp;gt;
</code></pre>
<p>显示效果：</p>
<p>&lt;http://example.com/ &gt;</p>
<p>&lt;address@example.com&gt;</p>
<h3 id="26-无序列表-有序列表-定义型列表">2.6 无序列表、有序列表、定义型列表</h3>
<ul>
<li><strong>无序列表</strong><br>
使用 *，+，- 表示无序列表。<br>
代码：</li>
</ul>
<pre><code class="language-undefined">* 无序列表项 一
+ 无序列表项 二
- 无序列表项 三
</code></pre>
<p>显示效果：</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三</li>
<li><strong>有序列表</strong></li>
</ul>
<p>有序列表则使用数字接着一个英文句点，注意标题无法形成列表，只能手动添加。</p>
<p>标题编号可通过<a href="https://www.cnblogs.com/Higurashi-kagome/p/12747857.html">MdAutoNumber.py</a>自动添加<br>
代码：</p>
<pre><code class="language-undefined">1. 有序列表项 一
2. 有序列表项 二
3. 有序列表项 三
</code></pre>
<p>显示效果：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
<ul>
<li><s><strong>定义型列表</strong></s></li>
</ul>
<p><s>语法说明：</s></p>
<blockquote>
<p><s>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</s></p>
</blockquote>
<p><s>代码</s></p>
<pre><code class="language-undefined">:   轻量级文本标记语言（左侧有一个可见的冒号和四个不可见的空格）
</code></pre>
<p><s>显示效果：</s></p>
<p><s>Markdown</s><br>
<s>:   轻量级文本标记语言，可以转换成html，pdf等格式</s></p>
<h3 id="27-插入图像">2.7 插入图像</h3>
<p>语法中<mark>图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片</mark>。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p>
<p>Markdown 语法：</p>
<pre><code class="language-xml">1. 图片居左题注居中
![img](http://zh.mweb.im/asset/img/set-up-git.gif &quot;图片Title&quot;)
&lt;!--格式: ![图片Alt](图片地址 &quot;图片Title&quot;)--&gt;

&lt;center&gt;
    GitHub set up
&lt;/center&gt;

2. 图片和题注居中
&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;http://zh.mweb.im/asset/img/set-up-git.gif&quot;/&gt;
    &lt;div align=&quot;center&quot;&gt;
    	GitHub set up
    &lt;/div&gt;
&lt;/div&gt;

3. 自由调整样式
&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; 
    src=&quot;http://zh.mweb.im/asset/img/set-up-git.gif&quot;&gt;
    &lt;br&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;GitHub set up&lt;/div&gt;
&lt;/center&gt;
</code></pre>
<p>效果如下：</p>
<div align="center">
	<img src="http://zh.mweb.im/asset/img/set-up-git.gif"/>
    <div align="center">
    	GitHub set up
    </div>
</div>
<figure data-type="image" tabindex="1"><img src="https:////upload-images.jianshu.io/upload_images/1496626-c3d52ee452341b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/310/format/webp" alt="img" loading="lazy"></figure>
<center>
    GitHub set up
</center>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="http://zh.mweb.im/asset/img/set-up-git.gif">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">GitHub set up</div>
</center>
<h3 id="28-多级引用">2.8 多级引用</h3>
<p>语法说明：</p>
<p>引用需要在被引用的文本前加上&gt;符号和空格，允许多层嵌套，也允许你偷懒只在整个段落的第一行最前面加上 &gt; 。</p>
<p>代码：</p>
<pre><code class="language-ruby">&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白
&gt;&gt; 自己看教程！ - 愤青
&gt; 教程在哪？ - 小白
</code></pre>
<p>显示效果：</p>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>自己看教程！ - 愤青</p>
</blockquote>
</blockquote>
<blockquote>
<p>教程在哪？ - 小白</p>
</blockquote>
<h3 id="29-转义字符-字体-字号-颜色">2.9 转义字符、字体、字号、颜色</h3>
<ul>
<li><strong>转义字符</strong></li>
</ul>
<p>Markdown中的转义字符为\，转义的有：</p>
<p>\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号  # 井号 + 加号 - 减号 . 英文句号 ! 感叹号</p>
<ul>
<li><strong>字体、字号、颜色</strong></li>
</ul>
<p>代码：</p>
<pre><code class="language-xml">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;
&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;
&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;
&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;
&lt;font color=gray size=5&gt;gray&lt;/font&gt;
&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;
</code></pre>
<p>显示效果：</p>
<p><font face="黑体">我是黑体字</font><br>
<font face="微软雅黑">我是微软雅黑</font><br>
<font face="STCAIYUN">我是华文彩云</font><br>
<font color=#0099ff size=12 face="黑体">黑体</font><br>
<font color=gray size=5>gray</font><br>
<font color=#00ffff size=3>null</font></p>
<h2 id="三-块语法讲解">三、块语法讲解</h2>
<h3 id="31-内容目录">3.1 内容目录</h3>
<p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<pre><code class="language-json">[TOC]
</code></pre>
<p>效果如下。</p>
<p>[TOC]<br>
<mark>此处可能由于Gridea解析器不支持此写法无法正确显示目录</mark><br>
<mark>欲查看请在Typora或其他支持此写法的编辑器内自行尝试</mark></p>
<h3 id="32-代码块">3.2 代码块</h3>
<p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用“`”符号（一般在ESC键下方）包裹代码。</p>
<ul>
<li><strong>行内式</strong></li>
</ul>
<p>代码：</p>
<pre><code class="language-cpp">C语言里的函数 `scanf()` 怎么使用？
</code></pre>
<p>显示效果：</p>
<p>C语言里的函数 <code>scanf()</code> 怎么使用？</p>
<ul>
<li><strong>缩进式多行代码</strong></li>
</ul>
<p>缩进 4 个空格或是 1 个制表符</p>
<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>代码：</p>
<pre><code class="language-cpp">#include &amp;lt;stdio.h&amp;gt;
int main(void)
{
    printf(&amp;#34;Hello world\n&amp;#34;);
}
</code></pre>
<p>显示效果：</p>
<pre><code class="language-cpp">#include &amp;lt;stdio.h&amp;gt;
int main(void)
{
    printf(&amp;#34;Hello world\n&amp;#34;);
}
</code></pre>
<ul>
<li><strong>用六个`包裹多行代码</strong></li>
</ul>
<p>代码：</p>
<pre><code class="language-cpp">、、、
include &lt;stdio.h&gt;
int main(void)
{
printf(&quot;Hello world\n&quot;);
}
、、、
</code></pre>
<p><strong>显示效果：</strong></p>
<pre><code class="language-cpp">include &lt;stdio.h&gt;
int main(void)
{
printf(&quot;Hello world\n&quot;);
}
</code></pre>
<h3 id="33-流程图">3.3 流程图</h3>
<p>流程图的编译语言有mermaid和flow，但不推荐在markdown里直接做复杂的流程图，建议用Tableau或Visio等专业绘图软件，故语法在此不过多赘述，只做简单演示，代码：</p>
<pre><code class="language-go">```
graph LR
A--&gt;B
```

```
sequenceDiagram
A-&gt;&gt;B: How are you?
B-&gt;&gt;A: Great!
```

```
flow
st=&gt;start: Start|past:&gt;http://blog.xiaoyulive.top
e=&gt;end: End:&gt;http://www.xiaoyulive.top
op1=&gt;operation: My Operation|past
op2=&gt;operation: Stuff|current
sub1=&gt;subroutine: My Subroutine|invalid
cond=&gt;condition: Yes or No?|approved:&gt;https://github.com/quanzaiyu
c2=&gt;condition: Good idea|rejected
io=&gt;inputoutput: catch something...|request

st-&gt;op1(right)-&gt;cond
cond(yes, right)-&gt;c2
cond(no)-&gt;sub1(left)-&gt;op1
c2(yes)-&gt;io-&gt;e
c2(no)-&gt;op2-&gt;e
```
</code></pre>
<p>显示效果：<br>
<mark>此处可能由于Gridea解析器不支持mermaid和flow从而无法正确显示图片</mark><br>
<mark>欲查看流程图请复制代码到Typora或其他支持解析的编辑器内渲染</mark></p>
<pre><code class="language-mermaid">graph LR
A--&gt;B
</code></pre>
<pre><code class="language-mermaid">sequenceDiagram
A-&gt;&gt;B: How are you?
B-&gt;&gt;A: Great!
</code></pre>
<pre><code class="language-flow">flow
st=&gt;start: Start|past:&gt;http://blog.xiaoyulive.top
e=&gt;end: End:&gt;http://www.xiaoyulive.top
op1=&gt;operation: My Operation|past
op2=&gt;operation: Stuff|current
sub1=&gt;subroutine: My Subroutine|invalid
cond=&gt;condition: Yes or No?|approved:&gt;https://github.com/quanzaiyu
c2=&gt;condition: Good idea|rejected
io=&gt;inputoutput: catch something...|request

st-&gt;op1(right)-&gt;cond
cond(yes, right)-&gt;c2
cond(no)-&gt;sub1(left)-&gt;op1
c2(yes)-&gt;io-&gt;e
c2(no)-&gt;op2-&gt;e
</code></pre>
<h3 id="34-表格">3.4 表格</h3>
<p>语法说明：</p>
<p>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br>
列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>
第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br>
<code>-</code> 左对齐， <code>:-:</code> 中心对齐，<code>-:</code> 右对齐</p>
<p>在<a href="#3.7">HTML原始码</a>里面有非原生方式的另一种表格写法（复杂表格推荐）。</p>
<p>表格代码：</p>
<pre><code class="language-ruby">|学号|姓名|序号|
|-|:-:|-:|
|小明明|男|5|
|小红|女|79|
|小陆|男|192|
</code></pre>
<p>原生方式写表格：</p>
 <center>
<table>
<thead>
<tr>
<th>学号</th>
<th style="text-align:center">姓名</th>
<th style="text-align:right">序号</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明明</td>
<td style="text-align:center">男</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td>小红</td>
<td style="text-align:center">女</td>
<td style="text-align:right">79</td>
</tr>
<tr>
<td>小陆</td>
<td style="text-align:center">男</td>
<td style="text-align:right">192</td>
</tr>
</tbody>
</table>
</center>
<h3 id="35-latex-公式">3.5 LaTeX 公式</h3>
<ul>
<li><strong>表示行内公式</strong></li>
</ul>
<p>代码：</p>
<pre><code class="language-bash">质能守恒方程可以用一个很简洁的方程式 `$E = mc^2 $`来表达。
</code></pre>
<p>显示效果：</p>
<p>质能守恒方程可以用一个很简洁的方程式 $E = mc^2 $来表达。</p>
<ul>
<li><strong>表示整行公式</strong><br>
大部分的浏览器支持</li>
</ul>
<pre><code class="language-ruby">$$
	公式
$$
</code></pre>
<p>有道云笔记 使用格式，</p>
<pre><code class="language-go">```math
公式
```
</code></pre>
<p>块级公式：</p>
<pre><code class="language-go">$$
	x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} 
$$

$$
	[\frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } }]
$$
</code></pre>
<p>显示效果：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.276389em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.590389em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.913389em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span></span></span><span style="top:-2.873389em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12661100000000003em;"><span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mfrac><mn>1</mn><mrow><mo fence="true">(</mo><msqrt><mrow><mi>ϕ</mi><msqrt><mn>5</mn></msqrt></mrow></msqrt><mo>−</mo><mi>ϕ</mi><mo fence="true">)</mo><msup><mi>e</mi><mrow><mfrac><mn>2</mn><mn>5</mn></mfrac><mi>π</mi></mrow></msup></mrow></mfrac><mo>=</mo><mn>1</mn><mo>+</mo><mfrac><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi></mrow></msup><mrow><mn>1</mn><mo>+</mo><mfrac><msup><mi>e</mi><mrow><mo>−</mo><mn>4</mn><mi>π</mi></mrow></msup><mrow><mn>1</mn><mo>+</mo><mfrac><msup><mi>e</mi><mrow><mo>−</mo><mn>6</mn><mi>π</mi></mrow></msup><mrow><mn>1</mn><mo>+</mo><mfrac><msup><mi>e</mi><mrow><mo>−</mo><mn>8</mn><mi>π</mi></mrow></msup><mrow><mn>1</mn><mo>+</mo><mo>…</mo></mrow></mfrac></mrow></mfrac></mrow></mfrac></mrow></mfrac><mo>]</mo></mrow><annotation encoding="application/x-tex">[\frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } }]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.01146em;vertical-align:-1.69002em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mopen"><span class="delimsizing size2">(</span></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.04139em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord mathdefault">ϕ</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">5</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.0013900000000002em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19860999999999995em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">ϕ</span><span class="mclose"><span class="delimsizing size2">)</span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.93957em;"><span style="top:-3.3485500000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">5</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.38em;"><span class="pstrut" style="height:3.15em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.827em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.69002em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.692383em;vertical-align:-2.201275em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.19358em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.91642em;"><span style="top:-2.4519800000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0543142857142858em;"><span style="top:-2.229757142857143em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size1 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32544em;"><span style="top:-2.468em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="minner mtight">…</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.387em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">8</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.61533em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size1 size6"></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">6</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2097642857142856em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3948549999999997em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.201275em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></span></p>
<p>访问 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmath.meta.stackexchange.com%2Fquestions%2F5020%2Fmathjax-basic-tutorial-and-quick-reference">MathJax</a> 参考更多使用方法。</p>
<h3 id="36-分隔线">3.6 分隔线</h3>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<p>代码：</p>
<pre><code class="language-undefined">* * *
***
*****
- - -
-----------
</code></pre>
<p>显示效果都一样：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<h3 id="span-id3737-html原始码span"><span id="3.7">3.7 HTML原始码</span></h3>
<p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p>
<p><strong>代码：</strong></p>
<pre><code class="language-xml">第一个例子：
&lt;div class=&quot;footer&quot;&gt;
© 2004 Foo Corporation
&lt;/div&gt;
第二个例子：
&lt;center&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
&lt;th&gt;星期一&lt;/th&gt;
&lt;th&gt;星期二&lt;/th&gt;
&lt;th&gt;星期三&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;李强&lt;/td&gt;
&lt;td&gt;张明&lt;/td&gt;
&lt;td&gt;王平&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;/center&gt;
</code></pre>
<p>显示效果：</p>
<p>第一个例子：</p>
 <div class="footer">
 © 2004 Foo Corporation
 </div>
<p>第二个例子：</p>
<center>
<table> <tr> <th rowspan="2">值班人员</th> <th>星期一</th> <th>星期二</th> <th>星期三</th> </tr> <tr> <td>李强</td> <td>张明</td> <td>王平</td> </tr> </table>
</center>
### 3.8 特殊字符
<center>
<table>
<thead>
<tr>
<th style="text-align:center">特殊字符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">字符的代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">空格符</td>
<td style="text-align:center"><code></code></td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于号</td>
<td style="text-align:center"><code>&lt;</code></td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于号</td>
<td style="text-align:center"><code>&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">和号</td>
<td style="text-align:center"><code>&amp;</code></td>
</tr>
<tr>
<td style="text-align:center">￥</td>
<td style="text-align:center">人民币</td>
<td style="text-align:center"><code>¥</code></td>
</tr>
<tr>
<td style="text-align:center">©</td>
<td style="text-align:center">版权</td>
<td style="text-align:center"><code>©</code></td>
</tr>
<tr>
<td style="text-align:center">®</td>
<td style="text-align:center">注册商标</td>
<td style="text-align:center"><code>®</code></td>
</tr>
<tr>
<td style="text-align:center">°C</td>
<td style="text-align:center">摄氏度</td>
<td style="text-align:center"><code>°C</code></td>
</tr>
<tr>
<td style="text-align:center">±</td>
<td style="text-align:center">正负号</td>
<td style="text-align:center"><code>±</code></td>
</tr>
<tr>
<td style="text-align:center">×</td>
<td style="text-align:center">乘号</td>
<td style="text-align:center"><code>×</code></td>
</tr>
<tr>
<td style="text-align:center">÷</td>
<td style="text-align:center">除号</td>
<td style="text-align:center"><code>÷</code></td>
</tr>
<tr>
<td style="text-align:center">²</td>
<td style="text-align:center">平方（上标²）</td>
<td style="text-align:center"><code>²</code></td>
</tr>
<tr>
<td style="text-align:center">³</td>
<td style="text-align:center">立方（上标³）</td>
<td style="text-align:center"><code>³</code></td>
</tr>
</tbody>
</table>
</center>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这里仅列出那些以编辑markdown文本为主要功能的编辑器，其他的比如notepad++等由于不是为了编辑Markdown而专门开发的，所以在使用体验、可拓展性和美观性上较差，故不推荐。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Markdown是一种纯文本标记语言 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>HyperText Markup Language 超文本标记语言 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>